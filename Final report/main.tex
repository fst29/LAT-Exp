\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage[a4paper, 
            top=2.5cm, 
            bottom=2.5cm,
            right=2.5cm,
            left=2.5cm]{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{changepage}
\usepackage[sorting=none]{biblatex} %Imports biblatex package
\usepackage{titlesec}
\addbibresource{references.bib}

%\titlespacing*{\section}
%{0pt}{2.2ex plus 1ex minus .2ex}{1.3ex plus .2ex}
%\titlespacing*{\subsection}
%{0pt}{1.4ex plus 1ex minus .2ex}{0.6ex plus .2ex}

%background: 5
%software: 10
%init: 2
% static fric: 10+3data
% dyn fric: 10+3data
%
%
%


\author{Fl칩ri치n Tiefenbeck (fst29)}


%\topmargin 0.0cm \oddsidemargin 0.0in \evensidemargin 0.0in
%\textheight 25cm \textwidth  17cm \headheight 0in \headsep 0in
\parindent 0in
%\parskip \bigskipamount
%\pagenumbering{gobble}
\begin{document}

\begin{center}
{\Huge \bf Final report}\\
\vspace{6pt}
{\LARGE \bf Experimental testing and modelling of a continuously variable transmission}\\
\vspace{4pt}
{\LARGE Fl칩ri치n Tiefenbeck (fst29, Peterhouse)}\\
%{\LARGE Michelmas, 2023 }
\end{center}

\section{Technical abstract}

\section{Background}
The design was conceived during a project where \todo names where trying to create a losslessly adjustable inerter and a losslessly adjustable spring. These are devices where the inertance or the spring constant can be changed during operation without any energy input. Their search was motivated by the ubiquity of variable dampeners commonly used in the auto industry. Linear devices were investaged initially such as the one shown in Figure \ref{fig:linvarspring}. This device has two terminals at (0,0) and ($x_1$, 0) where a force $F$ is applied. $k_0$ is a regular spring that has one end held stationary at (0, $y_0$) with the other end constrained to move in the $x$ direction. This end is connected to a lever that can pivot around the fulcrum at ($x_r$, $y_r$). If this point is movable, a lossless adjustable spring is realised as shown in \cite{8718377}. A possible realisation of this system is shown in Figure \ref{fig:linvarspring_physical}. The lever and the wheel can rotate along the vertical axis passing through the contact point of the wheel. The wheel is also allowed to freely rotate along a horizontal axis, thus moving the fulcrum along the length of the lever. 


\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Linear varspring.png}
    \caption{The linear varspring design}
    \label{fig:linvarspring}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{lin_varspring_realisation.png}
    \caption{A possible physical realisation of the linear varspring }
    \label{fig:linvarspring_physical}
\end{figure}

Later during their project, rotating devices were considerd. This eliminates the problem caused by physical limits and saturation (as explained in Lucas's paper). The two cone desing shown in Figure \todo was created. Attaching a spring or an inerter to one side of the transmission creates the losslessly adjustable device as desired. 





\subsection{Motivation}
As this is a new design, its operational parameters are generally unknown. This project aims to measure the most important such parameters such as the friction during operation or the slip between components.


\subsection{Design and operation}

\subsubsection{Transmission}
The main part of the transmission consists of two counterrotating cones on two parallel shafts. The cones are facing in the opposite direction, so that the distance between their surfaces remains constant. A carriage is suspended between the two cones, that is free to move along the length of the cone surfaces. The carriage holds two metal balls that are in contact with the cones and eachother. They can rotate freely in any direction, allowing torque to be transmitted from one shaft to the other.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{georg5-2917853-large.png}
    \caption{Schematic of the transmission}
    \label{fig:transmissionSchematic}
\end{figure}

\subsubsection{Operation}
The position of the carriage is described using a number called the $p$-value. The definition of the $p$-value:
$$p=\frac{\text{cone diameter at contact point between primary cone and ball}}{\text{cone diameter at contact point between secondary cone and ball}}$$ 

\todo check definition

The operation of the transmission can thus be described using two equations:

$$T_1=pT$$
$$\omega_1=\frac{\omega}{p}$$

These relationships ignore all friction and slip within the system.

\subsubsection{Auxillary components}
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{IMG_20231115_142939 resized.jpg}
    \caption{A photo showing the transmission and the auxillary components}
    \label{fig:photo}
\end{figure}

The primary shaft of the transmission is driven by a Talon FX Falcon 500 brushless DC motor. This motor has a built in controller and an encoder that can measure the shaft position. To eliminate issues caused by shaft misalignment, the shaft of the transmission is connected to the motor shaft through an Oldham coupling. 

A digital loadcell is built into the system between the coupler and the motor. This measures the torque inputted into the transmission system.

A rod extends from the freely moving carriage outside the enclosed part of the system, where it ends in a rack. A second Falcon 500 is mounted above this rack with a gear on its axle. This motor is used to move the carriage and thus change the "gear ratio" of the transmission system. 

These motors use the CAN protocol to communicate with the host. This is a two wire protocol widely used in the automotive industry, that allows multiple devices to communicate using just a pair of wires. A \todo  USB-CAN adapter is utilised to connect the motors to the Raspberry Pi.

The position of the carriage and the position of the primary shaft can be measured by the two motors, but the position and velocity of the secondary shaft cannot. A standalone encoder, an RE30E1024-213-1 from Nidec Components \cite{encoder}, is connected to the secondary shaft to overcome this issue. The encoder is connected to the shaft with a gear, so that the encoder axle rotates four times faster than the secondary shaft. The encoder is powered directly from the Raspberry PI and its output wires are also connected to the GPIO headers on the PI.

The secondary shaft is also attached to a torsional spring that can be used to simulate loads on the system. The other end of the spring can either be held stationary by a clamp or released to rotate freely if no load needs to be simulated. If the spring is connected, the system behaves as a lossless varspring described in Section \ref{\todo}.

A Raspberry PI 3 is used to control the apparatus and record measured data. The PI is connected to a \todo inch touchscreen which can be used to provide instantaneous feedback from the transmission. The screen is also used to input commands and start the experiments. 




\subsection{Dimensions}

\subsection{Use cases}
Continously variable transmissions are useful in applications where two shafts with different and preferred rotational speed have to be coupled in a way that can accomodate a change in these speeds.
A very common application is in the automotive industry. Internal combustion engines have a narrow RPM range where they are the most efficient but as the car's speed changes a conventional transmission system is not always able to keep the engine speed within range.
Another possible application is in wind turbines. In turbines where synchronous generators are used, the generator's rotational speed is kept constant by the grid frequency. On the other hand, the turbine blades can extract energy from the moving air most efficiently when their speed is \todo, where $v$ is the wind speed. To keep the turbine in this efficient regime at all times, a continously variable transmission can be used.

\todo ICE efficiency curve, wind TSR curve
\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{Cp-vs-Lambda-characteristics-for-various-blade-pitch-angle.png}
    \caption{The efficiency of a wind turbine versus tip speed ratio}
    \label{fig:enter-label}
\end{figure}


\subsection{Comparision to other CVT designs}
In other designs, such as the pulley based CVT shown in Figure \ref{todo} or the Evans Variable Speed Countershaft shown in Figure \ref{todo}, a frictional force must be overcome to change the torque ratio. Here the balls can rotate freely along the surface of the cone so no energy input is needed.
An other benefit compared to some other designs is the ability to change the torque ratio when the transmission system is statianory. This CVT can also transmit torque in both directions. 
A possible drawback compared to other systems, like the \todo is that the CVT cannot change the direction of rotation. This means that an other system is also required for automotive applications.




\pagebreak
\section{Software design}
All of the software used to control the experiments or manually move the motors was written during this project. There are two main programs running on the Raspberry Pi during operation. One is communicating with the sensors and the motors (backend), the other is communicating with the user (frontend). This separation allowed two different programming languages to be used for the two programs, so the strenghts of each language could be utilised.

\subsection{Backend}
The backend program is written in the C++ language. This was chosen for two reasons, the first is the inherent speed of the language as it is a compiled language. This allows the program to run at high speeds even on such relatively weak hardware as the Raspberry Pi. This enabled higher sampling frequencies to be used and finer control of the motors. The other reason for choosing this language was the availability of the official motor control library created by the manufacturers of the motors. This library contains makes interfacing with the motors a much simpler task by creating an abstraction layer. This means that in the backend program simple commands can be used to control the motors, which are then translated to the more complex low-level instructions by the library.

The backend program has two main parts, first a setup part that runs once on startup, then a loop that runs until the program is stopped.

The setup part estabilishes the connection with the motors, sets up the secondary encoder, initialises the message-reader and creates the file that is used to save all the measured data. The loop part has three main tasks, it collects measurements, it sends commands to the motors and saves the collected data to the output file.  


\subsubsection{Motor setup}
The motor setup utilises functions from the afforementioned motor library. Initially communication is estabilished with the motors using the CAN bus adapter. Once a stable link is created, the PID parameters, the maximum torque, the maximum speed, maximum acceleration, the internal loop frequency, and the maximum current draw get set. The values used here were determined previously and were not changed. 

\subsubsection{Secondary encoder}
The encoder connected to the secondary shaft is connected directly to the Raspberry Pi using the GPIO headers. The encoder is an incremental quadratic type, which means it has two outputs (A and B) which change as shown in Figure \ref{fig:encoder}. At each encoder tick (corresponds to 1/1024 of a full rotation of the encoder equal to 1/(1024*4) of the seconder shaft) one of the two signals changes. By treating the encoder as a two bit state machine a state transition table can be created as shown in Table \ref{tab:output_encoder}.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
        Previous  & Current  & Movement&Value of & Value in \\
        state (A\textsubscript{n-1}B\textsubscript{n-1}) & state (A\textsubscript{n}B\textsubscript{n})&&\verb|output_encoder_state|& lookup table\\%\verb|state_transition_matrix| \\
        \hline
         00&00&None&0000\textsubscript{2}=0\textsubscript{10}&0\\ 
         00&01&CCW&0001\textsubscript{2}=1\textsubscript{10}&+1\\ 
         00&10&CW&0010\textsubscript{2}=2\textsubscript{10}&-1\\ 
         00&11&Error&0011\textsubscript{2}=3\textsubscript{10}&0\\ 
         
         01&00&CW&0100\textsubscript{2}=4\textsubscript{10}&-1\\ 
         01&01&None&0101\textsubscript{2}=5\textsubscript{10}&0\\ 
         01&10&Error&0110\textsubscript{2}=6\textsubscript{10}&0\\ 
         01&11&CCW&0111\textsubscript{2}=7\textsubscript{10}&+1\\ 
         
         10&00&CCW&1000\textsubscript{2}=8\textsubscript{10}&+1\\ 
         10&01&Error&1001\textsubscript{2}=9\textsubscript{10}&0\\ 
         10&10&None&1010\textsubscript{2}=10\textsubscript{10}&0\\ 
         10&11&CW&1011\textsubscript{2}=11\textsubscript{10}&-1\\ 
         
         11&00&Error&1100\textsubscript{2}=12\textsubscript{10}&0\\ 
         11&01&CW&1101\textsubscript{2}=13\textsubscript{10}&-1\\ 
         11&10&CCW&1110\textsubscript{2}=14\textsubscript{10}&+1\\ 
         11&11&None&1111\textsubscript{2}=15\textsubscript{10}&0\\ 
         \hline
    \end{tabular}
    \caption{State transition table of the secondary endcoder (Note that the actual values of the lookup table are scaled to give result in degrees)}
    \label{tab:output_encoder}
\end{table}

During this part of the program interrupts are attached to the two encoder pins. These interrupts call the same function (called \verb|encoder_callback|) if one of the signals changes in either direction.

A global variable called \verb|output_encoder_state| is also created, this is a four bit number that represents the current and the previous state of the encoder signals in the format (in binary) A\textsubscript{n-1}B\textsubscript{n-1}A\textsubscript{n}B\textsubscript{n}. 

A lookup table (\verb|state_stranstion_matrix|) is also created from the state transition table shown in Table \ref{tab:output_encoder}. It has 16 elements corresponding to each possible transition, the positive transitions have value +1, the negative transitions have value -1, the entries corresponding to no movement or error have value 0. After creating the table, its values get scaled by 360/(1024*4) to get the result in degrees.

When the callback function is called, \verb|output_encoder_state| gets bit-shifted left by two bits and bitwise ended with 1100, effectively moving the "current" measurement to the location of the previous and deleting the previous. After the shift, the lower two bits get populated with the new values of the encoder output. The last step of the callback function is to add the value of the state transition matrix to the variable that stores the position of the secondary shaft. This is implemented by adding the \verb|output_encoder_state|'th element of the \verb|state_transition_matrix| array to the position variable.

Using these bitwise operations and the lookup table allows the callback function to be executed very quickly. This is important as this is an interrupt so the rest of the program is halted while this runs.




\begin{figure}[!h]
    \centering
    \includegraphics[width=0.8\textwidth]{encoder_waveform.png}
    \caption{The output waveforms of the encoder, Figure from \cite{encoder}}
    \label{fig:encoder}
\end{figure}



\subsubsection{Message-reader}
During the setup phase a second thread is started. On this thread a loop is running, that checks the specified named pipe for new commands. If no message is received, this thread waits until a message is sent by the frontend. When it detects a message, it reads it into memory and calls two functions to convert the raw text into usable commands. Each message has a keyword that specifies the action and, depending on the keyword, some numerical arguments delimited by spaces. The first function is \verb|get_command()|, which extracts this keyword from the message. The second function, \verb|get_command_vaues()| is used to extract these arguments from the message. These extracted values then get stored in global variables that can be read by the main loop of the program running on the other thread. 


\subsubsection{Output file}
As the last step of the setup, the log file is created. This .csv file stores all the data collected by the Raspberry PI during the experiments. The name of this file is the current date and time. At this point the first row is filled with the following columns: Time (HH:MM:SS), Milliseconds, Command, State, PosTarget, RatioTarget, Drive position, Drive velocity, Drive current, Carriage position, Carriage velocity, Carriage current, Output position, Output velocity. At each iteration of the main loop a new row is added to the file with the data.



\subsubsection{Timing of the loop}

Two methods of timing the main loop where tested during this project as shown in Figure \ref{fig:timings}. The first method used an infinite loop running constantly and checking the elapsed time in every iteration, if the time since the last execution exceeds the set time, the main part of the program is entered, where measurements are taken, the motors are controlled and data is saved. This approach would work well on systems without an OS, where only one program is running at a time. Here, where several other programs are trying to use the CPU at the same time, constantly checking for the time elapsed is not a good solution as it uses up resources and slows down other programs.
The seconds also uses an infinite loop but instead of checking the time in every iteration, the thread is put to sleep after each iteration. To achieve accurate timings, the execution of the main part is measured and the sleep time is set, so that the thread sleeps for the remainder of the loop time. If the execution of the main part takes longer than the predefined loop time, an error is shown.
Changing to the second option fixed problems that lead to unexpected crashes of the program. No difference in timing accuracy could be measured between the two methods.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Timing.drawio.png}
    \caption{The two methods of timing the main loop}
    \label{fig:timings}
\end{figure}



\subsubsection{Collecting measurements}
The first part of the loop deals with measurements, the \verb|get_measurements| function is called. Within this function the current time from the system clock is saved to provide a timestamp for the measurement. Then communication with the motors is initiated over the CAN bus to request the latest position, velocity and current measurement from the motors internal systems. The received values are converted to degrees in the case of the drive motor and $p$-value in the case of the carriage motor. The received values are saved in variables that will later be used for control and logging. At this stage a measurement message is prepared in the format specified in Section \ref{sec:comms}. The formatted message is then written to the named pipe for the frontend to read.




\subsubsection{Executing commands}
Two type of commands have been used during this project, a simple command that takes one iteration of the loop to execute and complex commands that take several loops. 
\begin{table}[]
    \centering
    \begin{tabular}{|l|l|}
         \hline
         \textbf{Simple commands}&\textbf{Complex commands}  \\
        \hline
         \verb|STOP| (0)&\verb|INITIALISE_DRIVE| (0)\\
         \verb|CARRIAGE_GOTO| (1)&\verb|INITIALISE_CARRIAGE| (0)\\
        \verb|DRIVE_GOTO| (1)&\verb|STATIC_FRICTION| (0)\\
        \verb|CARRIAGE_SET_POS| (1)&\verb|DYNAMIC_FRICTION| (0)\\
        \verb|DRIVE_SET_POS| (1)&\\
        \verb|OUTPUT_SET_POS| (1)&\\
        \verb|PID_DRIVE| (4)&\\
        \verb|DRIVE_SINE| (3)&\\
        \hline    
    
    \end{tabular}
    \caption{The possible commands with the amount of parameters in parantheses}
    \label{tab:my_label}
\end{table}\\

\verb|STOP|\\

When this command is received, the supply of the motors is removed so they immediately start slowing down.\\

\verb|CARRIAGE_GOTO| and \verb|DRIVE_GOTO| \\

These commands can be used to set the carriage to a desired $p$-value and to move the primary shaft to a specified position. The arguments sent with these functions is the desired $p$-value and the final position in degrees. Both commands use the motor controller's built-in 'MotionMagic' controller. This generates a smooth velocity profile between the current position and the final position with predefined acceleration and maximum velocity values. \\

\verb|CARRIAGE_SET_POS|, \verb|DRIVE_SET_POS| and \verb|OUTPUT_SET_POS|\\

These commands can be used to overwrite the stored encoder positions. These are useful after restarting the program, as the encoder positions are reset to 0 after each restart.\\

\verb|DRIVE_PID|\\
The four parameters of this command: $k_p$, $k_i$, $k_d$ and $k_f$. When this command is received the values are sent to the built in motor controller to change the PID tuning of the drive motor.\\

\verb|DRIVE_SINE|\\
When this command is executed, the drive motor is driven in a sinusoidal pattern with the specified amplitude, offset and frequency.\\

The defining feature of complex commands is that their execution spans over several loops of the program. The \verb|state| variable is utilised to keep track of the currently executed part of the command. The \verb|target| variable is used to store a calculated target position or target torque that is to be used during the next iteration. These variables are saved along with other data to the log file. A detailed explanation of the execution of the complex commands is included in their relevant sections.
 


\subsubsection{Saving data}
After the command has been executed, the next row of the log file is filled with data. Each row contains the timestamp recorded when the measurements were taken. The currently active command and its state are included as well as the other measured values listed in Section \ref{sec:outputFile}. 


\subsection{Frontend}
The frontend is made using the Python language and the Tkinter GUI module. The language was selected because it is a high level language that enables quick development. The main drawback of the language is its relatively slow execution time but this is not relevant for a user interface. The Tkinter module makes GUI development simpler by adding pre-built interface elements, such as buttons or textboxes. These can be configured and placed in the window to build up the user interface. The module also offers touchscreen compatibility, which is required here. 

Visually the window is split vertically into two sections. The upper part contains the numpad and measured data display area. The lower part is used to control the apparatus with different commands split across the different tabs.

The frontend utilises two threads, just like the backend. The first thread is responsible for the received messages from the backend, the other thread handles the input from the user and sends it to the backend.


\subsubsection{Numpad}
As the Raspberry Pi is not connected to any keyboards, only the touchscreen, the only way to input numbers was the on-screen keyboard of the operating system. Using this proved to be cumbersome as this is a full keyboard that takes up most of the screen. During operation only numerical data needs to entered, therefore a numpad was included in the user interface, that is always visible and enters numbers into the selected textbox. The numpad contains the numbers 0-9, a decimal point, a negative sign and a backspace key. Switching from the OS's keyboard to this numpad made using the GUI significantly faster.


\subsubsection{Measurement display area}
This area remains visible at all times and shows the position and velocity of all encoders, the current draw of both motors is also displayed. This area is updated using the first thread of the frontend, where an infinite loop is running, which checks for a message coming from the backend in each iteration. If no message is received it halts until a message appears. When a message is received it checks whether the format of the message is correct and raises an error if it isn't. In the next step the data is extracted from the message and the text displayed in the measurement display area gets updated. 

\subsubsection{STOP button}
A stop button is also visible on the GUI at all times. This can be used to quickly stop the movement of all motors.


\subsubsection{Manual page}
The first page that comes up when the program is started is the manual page shown in Figure \ref{fig:manual}. On this page both motors can be driven manually to a position. There are also buttons to move the driveshaft or the carriage a a small amount (5춿) in either direction. On this page the measured position can be overwritten manually. This is necessary if the program is restarted, as the encoders can only measure change in position, not absolute position. If the position is known it can be entered on the manual page, if it is not, the initialisation algorithms (Section \ref{} \todo) can be used to determine the position.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{manual.png}
    \caption{The manual page of the GUI}
    \label{fig:manual}
\end{figure}

\subsubsection{Initialise page}
\subsubsection{Sinusoidal page}
\subsubsection{PID page}

\subsubsection{Sending commands}
\subsubsection{Receiving measurements}

\subsection{Communication}
Communication between the two programs is accomplished using named pipes \cite{MKFIFO}. This is a built in system found in Unix-like operating systems (such as the Raspberry PI OS) that allows the creation of a pipeline that two separate programs can read simultaniously. These pipes can be read and written to just like regular files except that when a message on a named pipe is read, it is also removed from the pipe. 
Two other methods were investigated: regular files and shared memory addresses. The main drawback of regular files is that only one file can open it at a time, so the reader would have to open the file and check for changes regularly. This leads to problems when the writer tries to send a message at the same time. Named pipes don't have this problem as both processes can open the file at  the same time. 
Shared memory addresses do offer higher data throughput but since the amount of data transmitted here is relatively low, this is greatly outweighed by the the ease of setting up named pipes. 


\subsubsection{Commands}
Commands are sent from the frontend to the backend. A single transmission always carries one command. The command consists of a keyword followed by some parameters although some keywords do not need parameters. The parameters are formatted as floating point number and they are separated from the keyword and the other parameters by spaces. A possible command message is shown in Figure \ref{fig:commandMessage}. Keeping the keywords and the numbers in this human-readable format makes it possible to read these messages with other programs that makes debugging easier. It also allows other programs to emulate the behaviour of the frontend by writing to this named pipe by hand. This way the backend can be used without the frontend. 

\todo named pipe pic

\subsubsection{Measurements}
Measurements are sent from the backend to the frontend. Here a single transmission hold all the data measured at a timestamp. Each measurement is transmitted as a name-value pair separated by a space, the pairs are also separated by spaces. While transmitting the names with every transmission is not strictly necessary, the decoder could decode the message without it, as the order of measurements is always the same, it is kept included so that the sent message can be read easier without a preprogrammed decoder. Including the names allows an extra check to be performed on the data to check its integrity which would be more difficult if the message only contained a list of numbers. Figure \ref{fig:measurementMessage} shows a possible measurement message.


\pagebreak
\section{Initialisation algorithms}
All the encoders used on the apparatus are incremental encoders which means that they only measure a change in position, they cannot measure absolute position. Before an experiment can begin the current position of the shafts and the carriage must be entered through the interface's manual tab. If this is not known, the following methods can be used to initialise the encoders.

\subsection{Primary shaft}
The primary shaft does not have any features that would allow a program to find the zero position. Instead an eyepiece with a line on it is mounted above the shaft. When this line is aligned with the line on the primary shaft, the shaft is at the 0춿 position. This eyepiece was added to the transmission system as a part of this project. This involved choosing the right eyepiece and designing the mount for it (shown in Figure \ref{fig:eyepieceMount}). This mount was then manufactured by the technicians of the department. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{Eyepiece_mount.png}
    \caption{The CAD model of the eyepiece}
    \label{fig:eyepieceMount}
\end{figure}



\subsection{Secondary shaft}
If the absolute position of the secondary shaft is not known, it can be initialised using the endstops, the 0춿 position is defined to be halfway between the two endstops. This initialisation can be accomplished by a premade algorithm that can be started on the touchscreen interface. Initially the system is slowly driven in the positive direction using its built in controller. At every loop the velocity is checked, if it falls to zero, it is assumed that the output shaft has hit the endstop. This position is saved and the drive is driven in the negative direction. When it stops again, the other endstop's position is saved and the zero position is calculated. Finally the output shaft is moved back to the 0춿 position.\\
The main difficulty encountered during the implementation of the algorithm was the tuning of the speed. If it is set too low, the shaft could get stopped before it actually reaches the endstop due to the changes in friction. On the other hand if it is set to a too high value, the output shaft slams forcefully into the endstop which could damage the components. 


\begin{figure}
    \centering
    \includegraphics[width=0.2\textwidth]{DriveInit.drawio.png}
    \caption{The initialisation algorithm of the secondary shaft}
    \label{fig:driveInit}
\end{figure}


\subsection{Carriage}
The carriage also does not have any easily identifiable features that could be used for initalisation. It does not have purpose made endstops, its movement is only limited by the enclosure. The option of using this to find the absolute position was considered but eventually not used due to the fact that neither part was designed to handle impacts like this. Repeatedly hitting the walls of the enclosure could damage the carriage or cause it to get out of alignment.\\
The position of the carriage is instead measured indirectly by measuring the $p$-value using the relative movement of the two shafts. At two different carriage positions the primary shaft is moved 50춿 from its starting position, the displacement of the secondary shaft is measured and thus the $p$-value can be calculated. Measuring the $p$-value at two different positions allows the change in $p$ per encoder tick to be calculated using the fact that the $p$-value changes linarly with the carriage position, which is also directly proportional to the rotation of the carriage motor. 
 

\pagebreak
\section{Static friction}
\subsection{Motivation}
An important part of the model that describes the CVT is the torque needed to get the shafts moving from a stationary position. It is expected that the torque required at this stage is somewhat higher than the dynamic friction during continuous movement. This part of the project aims to characterise the friction and its dependence on the $p$-value. During initial tests it was found that the static friction, also depends on the angular position of the cones, this dependence is also analysed. 





\subsection{Static friction model}




\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Static friction model wo RR.drawio.png}
    \caption{The static friction model}
    \label{fig:staticFricModel}
\end{figure}

Figure \ref{fig:staticFricModel} shows a model of the transmission system with the forces and torques acting on the components. Torques labeled $F_i$ are the limiting static friction torques acting in the bearings of the shafts and the balls, the rolling resistance is also incorporated into these torques (see Section \ref{sec:rollingFric}). Forces labeled $I_{i-j}$ are the static friction forces acting between the components, these forces carry the torque through the system. $T_{motor}$ is the torque of the motor that drives the primary shaft, as the spring is disconnected during this experiment, there is no torque acting on the secondary cone other than the friction in its bearings. \\

As none of the components move at this point, the forces and torques shown in Figure \ref{fig:staticFricModel} must balance. In order to refer forces and torques between components, their radii must be known, let $R_1$ and $R_2$ be the radius of the primary and secondary cones  respectively at the contact points and let the radius of the balls be $R_b.$\\

Equating the forces and torques starting from the secondary cone:\\

$$I_{3-4} = \frac{F_4}{R_2}$$

$$I_{2-3} = I_{3-4}  + \frac{F_3}{R_b} = \frac{F_4}{R_2} + \frac{F_3}{R_b}$$

$$I_{1-2} = I_{2-3} + \frac{F_2}{R_b} = \frac{F_4}{R_2} + \frac{F_3}{R_b}  + \frac{F_2}{R_b}$$

$$T_{motor} = R_1 I_{1-2} + F_1 = F_1 + R_1 \left(\frac{F_4}{R_2}  + \frac{F_3}{R_b}  + \frac{F_2}{R_b} \right) $$

To simplify this equation the definition of the $p$-value can be used:
$$p=\frac{R_2}{R_1}$$

Also, since the cones are aligned in a way so that $R_1+R_2 = R_1(1+p)$ is a constant, the relationship between $R_1$ and $R_b$ can be expressed in terms of $p$:
$$\frac{R_1}{R_b} = \frac{c}{(1+p)}$$
where $c$ is a constant.
Using these equations, the torque of the motor in the static friction case can be expressed as:
$$T_{motor} = F_1 + \frac{F_4}{p} + \frac{c(F_2+F_3)}{1+p}$$

Initially the values of $F_i$ were assumed to be constant, so that the motor torque required to get the system moving would only depend on the $p$-value. This assumption turned out to be false, as the friction torque exhibits a stong dependence on the angular position of the shafts. To characterise these variations, it is assumed that $F_1$ depends on the angle of the primary shaft ($\alpha$), while $F_4$ depends on the angle of the secondary shaft ($\beta$).



\subsubsection{Modelling rolling friction}
\label{sec:rollingFric}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Rolling friction model.drawio.png}
    \caption{The model of rolling resistance used during the analysis}
    \label{fig:rollingFriction}
\end{figure}


As an object rolls over another their surfaces deform elastically, this causes elastic forces to arise between the two objects. These forces align in a way that they counteract the motion so they can be modelled using an offset net force as shown in Figure \ref{fig:rollingFriction}) This offset force is equivalent to a torque and a force, whose line of action passes through the centre of the rolling object. This allows the incorporation of the rolling friction into the torques $F_i$ above. The forces normal to the surfaces are not shown in Figure \ref{fig:staticFricModel}.   





\subsection{Method and program}

\begin{figure}[h]
    \centering
    \includegraphics[width=.3\textwidth]{StaticFriction.drawio.png}
    \caption{The flowchart describing the static friction program}
    \label{fig:staticFricFlowchart}
\end{figure}

The goal of this experiment is to measure the torque required to get the transmision system moving at different shaft positions and $p$-values. Initially the drive motor torque is set to a low value and then it is increased slowly in several steps. If no movement is detected using the encoders, the torque is increased to the next level. A typical torque-time plot of the experiment is shown in Figure \ref{fig:staticFricTorqueTime}. If movement is detected, the position of both shafts and the $p$-value is recorded for later processing and the torque is reduced. After the trasmission has moved to the next measurement position and it has stopped there, the process repeats.\\

The static friction is measured over the whole range of motion of the output shaft nine times, at three different $p$-values and at each $p$-value with three different shaft offsets. This makes it possible to separate the effect of the input shaft's static friction from the output shaft's static friction.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{staircase.png}
    \caption{The torque during the static friction test}
    \label{fig:staticFricTorqueTime}
\end{figure}

The algorithm that controls this experiment can be started using the "Dynamic Friction" button on the touchscreen GUI's experiments page. The experiment is run using a state machine with three states. When the program starts it is in the start state, here the starting position of both shafts get saved and the torque is set to 75\% of the previous peak. During the first few versions of the program the torque was always set to a predefined value but this lead to very long ramp-up times when the transmission was in a high torque region. Using a fraction of the previous peak value as the next starting point speeds up the experiment significantly. This does not lead to measurement errors as the static friction torque does not change that much between neighbouring measurement points. \\

After the starting value has been calculated, the program moves to the ramp-up state. When the program enters this state it checks for movement of the transmission system by comparing the current encoder positions to the previously saved starting positions.  \\

If no movement is detected, a counter is incremented, this counter is used to create the parts of the staircase-like torque graph. When the counter value is smaller than 30 (corresponding to 300 ms) the current torque value is kept. When the counter reaches 30, the torque is increased by the predefined percentage step (0.1\% was used) and the counter is reset to 0.\\

If movement is detected, the motor torque is set back to zero and the program enters the cooldown state. At this point the program also checks whether the output shaft is getting close to its endstops, if that is the case the direction of movement is reversed.
The cooldown state is necessary as the motor current cannot change instantaneously, the coils of the motors need time to collapse their electric fiels before the torque reduces. At this point the shaft is also moving so it has to be stopped before the next measurement cycle can begin. At every loop of this state the motor current and the speed of the shaft is checked, if both have fallen to zero, the program progresses to the start state and the next measurement is taken.


\subsection{Data synchronisation}

\begin{figure}[h]

    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing,1.png}
        
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing2.png}
        
    \end{minipage}

    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing3.png}
        
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing4.png}
        
    \end{minipage}
    \caption{The three steps of the syncing process along with the variation of syncing error with offset}
    \label{fig:syncing}
\end{figure}



The data saved by the program made during this project attaaches a timestamp with millisecond precision to every recorded datapoint. The data of the load cell that measures the torque of the motor is not recorded using this program, instead the cell's own application is used to record data. The datapoints recorded here also have a millisecond precision timestamp but in this case the timestamp only shows the time elapsed since the first measurement. While the timestamp of the first measurement does have an absolute date and time, this is only given to the nearest second. This means that while the timestamps are very precise, they are not accurate enough to be used without a synchronisation step.\\

To synchronise the two datasets, the current measurements (measured by the program written during the project) are compared to the torque measured by the cell. These two datasets were selected because they are linearly proportional in a DC motor. One of the "staircases' shown in Figure \ref{fig:staticFricTorqueTime} are selected in each dataset, the one second accuracy is good enough to easily identify a matching pair. When a pair is identified, they are scaled so that their peak value is the same, as they are linearly proportional, this should create two identical functions that are offset by some amount of time. One of these datasets are moved along the time axis until the squared difference between the two datasets is minimised. When this time offset factor is found, the whole dataset is shifted by this amount to achieve synchronisation.


\subsection{Data processing}
The syncronised torque data is then further processed using an other program. This program finds the peaks of these staircases and creates a new data file where the peak torque, the corresponding shaft positions and the carrige position are stored. This greatly reduces the amount of data that must be processed further and since for this experiment only the torque at which the transmission starts moving carries useful information, the deleted datapoints do not influence the results. 


\subsection{Problems with movement detection}
The initial static friction tests produced data that is shown in Figure \ref{fig:beforeFix}.  

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{staticFrictionBeforeFix.png}
    \caption{Data collected using the old movement detection}
    \label{fig:beforeFix}
\end{figure}

In the Figure a clear trend is visible with most points being grouped very tightly around this line but some recorded static friction datapoints are below the rest. Further inspection of the collected data showed that when these points that do not follow the trendline have been recorded the transmission only moved 1 encoder tick (0.17춿) on the primary side and then stopped again. Also no movement was detected on the secondary side. The original movement detection check only looked at the primary side so this was enough for the program to think that static friction was overcome. Further tests showed that the transmission system is able to elastically deform a small amount under the load without actually breaking static friction. If the system comes to rest close to the boundary between two encoder ticks, a very small amount of movement can move it to the next tick and cause movement to be detected.\\

The solution to this problem was a change to the movement detection, instead of triggering on a single tick change, the primary shaft has to move at least two ticks (0.37춿) before the ramp-up is stopped and the static friction is considered broken. Additionally, movement at both the input and output shaft must be detected for the algorithm to trigger. This change has reduced the number of these false positives. 



\subsection{Collected data}
The static friction was recorded at three different $p$-values and three different offsets, in total more than 4000 measurements were taken. Over a single run the static friction was measured every 0.75춿 along the axles. The collected static friction data has been plotted against the position of the input shaft and the position of the output shaft. Some of these plots are shown in Figure \ref{fig:staticFrictionData}. The data was plotted this way to identify whether the variation with position correlates with the position of one of the cones. This did not lead to any conclusion and later calculations showed that the friction depends on both shaft positions independently. At each position the friction was measured twice, once in the positive direction and once in the negative direction, these datapoints are shown in different colour. The increased density of datapoints on the left side of the first plot in Figure \ref{fig:staticFrictionData} is due to the fact that the primary cone was in that position twice during the experiment. As $p>1$, the primary cone rotates more than the secondary cone, so it goes more than a full circle while the secondary shaft moves from one endstop to the other (around 330춿). Similarly, on the plots where $p<1$, a gap is visible as the primary shaft does not go all the way around.
 
\begin{figure}[!h]
\label{fig:staticFrictionData}
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, op.png}
    \end{minipage}
\caption{Some of the static friction data collected}
\end{figure}



The data recorded at different $p$-values and different offsets are included in Appendix A.
The variation with $p$-value visible in the plots is expected, as the friction of the secondary shaft is referred to the primary. On the other hand, the dependence on the position is not explained by the simple model described above.










\subsection{Curve fitting}
The next part of this project focused on modeling this positional dependence of the static friction. Quantifying the dependance of the static friction on the shaft positions and the $p$-value makes it possible to create a model that describes the operation of the transmission system. The model is based on the equation from Section \ref{sec:staticFricTheory}:
$$T_{motor} = F_1 + \frac{F_4}{p} + \frac{c(F_2+F_3)}{1+p}$$

It is assumed that $F_1$ varies with the position of the input shaft ($\theta_1$) and $F_4$ depends only on the position of the secondary shaft ($\theta_4$). The dependance of $F_2$ and $F_3$ on these positions were analysed but no correlation with either $\theta_1$ or $\theta_4$ was found so their sum was assumed to be constant. Two splines were considered for the friction values, a quadratic in the form:
$$F_i = a_i \theta_i^2 + b_i \theta_i + c_i$$
and a sinusoidal in the form:
$$F_i = a_i \sin\left( \theta_i + \phi_i  \right)  + c_i$$

The coefficients of the splines ($a_i$, $b_i$, $c_i$, $\phi_i$) were optimised using Scipy's \verb|curve_fit| function \todo reference. to achieve the lowest squared error between the measured data and the fitted curves. The value of the ball friction ($c(F_2+F_3)$) was also entered into the fitting process, the best fit value is denoted $c_3$ in the tables below.\\

Table \ref{tab:staticFricCoeffs} contains the best fit coefficients of the two curves and \ref{fig:staticFitCurves} shows the best fit curves plotted against the shaft positions ($F_1$ against $\theta_1$ and $F_4$ against $\theta_4$).
 
\begin{table}[h]
    \centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{Quadratic}     & \multicolumn{2}{|c|}{Sinusoidal}    \\ \hline
a1        & -2.59E-06 & c1         & 2.19E-01 \\ \hline
b1        & 6.15E-05  & c2         & 1.28E-01 \\ \hline
c1        & 2.46E-01  & c3         & 1.01E+00 \\ \hline
a2        & -2.98E-06 & a1         & 3.86E-02 \\ \hline
b2        & -1.22E-05 & a2         & 3.86E-02 \\ \hline
c2        & 1.58E-01  & p1         & 83.1춿\\ \hline
c3        & 3.37E-01  & p2         & 87.7춿 \\ \hline
\end{tabular}
    \caption{The best fit coefficients.}
    \label{tab:staticFricCoeffs}
\end{table}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{StaticF1.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{StaticF4.png}
    \end{minipage}

\label{fig:staticFitCurves}
\caption{The best fit $F_1$ and $F_4$ curves}

\end{figure}

The static friction can therefore be modeled as a single function of the shaft positions and the $p$-value using the following equations. (with $\theta$ in degrees)
If the quadratic fit is used:\\

$$F_{total} (p, \theta_1, \theta_4) = a_1 \theta_1^2 + b_1 \theta_1 + c_1 + \frac{ a_4 \theta_4^2 + b_4 \theta_4 + c_4 }{p} + \frac{c_3}{1+p}$$

If the sinusoidal fit is used:\\
$$F_{total} (p, \theta_1, \theta_4)= a_1 \sin\left( \theta_1 + \phi_1  \right)  + c_i + \frac{a_4 \sin\left( \theta_4 + \phi_4  \right)  + c_4}{p} + \frac{c_3}{1+p}$$

The general shape of the two curves is similar in both caseb but the quadratic curve does achieve a somewhat lower squared error. During the fitting process the quadratic curve was not restrained to produce a curve which is continous from 180춿 to -180춿. This lead to a curve that has a small jump at this position which is unphysical, the sinusoidal curve inherently avoids this problem and produces a curve that is continuous everywhere.

\comparison between fits

 
\subsection{Conclusions}
The dependence of static friction on the position of the carriage follows the expected relationship calculated in Section \ref{sec:statFricModel}. At higher $p$-values a lower torque is needed to get the transmission system moving. \\

The positional dependence cannot be explained so simply. Several factors could contribute to the profile seen in the plots above. The shaft not being at the centre of each cone could cause cause the distance between the cone surfaces to vary as they turn. At alignments where the cone surfaces are closer, the balls would have to compress more, leading to higher normal forces between the cones and the balls, ultimately causing higher static friction. The same variation in distance between the cones could be caused by the cone surfaces not being perfectly circular.\\

The overall trends of the static friction data can be explained by these effects, the local deviatiions from the trend visible in the plots can be caused by local surface effects at those cone positions. For example if the balls stop in a small dimple on the cone surface, a higher torque will be needed to get it moving again.



\pagebreak

\section{Dynamic friction}
\subsection{Motivation}
It is assumed that most of the energy losses in the system are due to the dynamic friction between components. These forces and torques could be caused by the rolling friction between the balls and the cones or by the bearings that hold the components. This experiment tries to find the sources and the magnitudes of these losses. Creating a model that accurately describes the operation of the transmission system requires the accurate description of the dynamic friction torques and their dependence on the $p$-value and the shaft positions.



\subsection{Theory}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Dynamic friction model.drawio.png}
    \caption{The dynamic friction model}
    \label{fig:dynFricModel}
\end{figure}
Figure \ref{fig:dynFricModel} shows the forces and torques acting on the components during the dynamic friction experiment, the torques labeled $F_i$ are the dynamic friction forces between the components, $I_c$ is the moment of inertia of a cone assembly and $\alpha_i$ is the angular acceleration of the component. The rest of the labels have the same meaning as in Figure \ref{fig:staticFricModel}. the inertial forces acting on the balls are ignored, as explained in Section \ref{sec:momentOfInertiaCalcs}. 
Based on the result in Section \ref{sec:staticFrictionModel}, the motor torque can be calculated:
$$T_{motor} = F_1 + I_c\alpha_1 + \frac{F_4 + I_c \alpha_4 }{p} + \frac{c(F_2+F_3)}{1+p}$$

This can be simplified by noting that the ratio of accelerations only depends on the $p$-value: $\alpha_4 = \frac{\alpha_1}{p}$

$$T_{motor} = F_1 + \left(1+\frac{1}{p^2}\right)I_c\alpha_1 + \frac{F_4 }{p} + \frac{c(F_2+F_3)}{1+p}$$



\subsection{Moment of inertia calculations}

$\Ddot{\alpha}$

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{coneCrossSection.png}
    \caption{The cross section of the cones}
    \label{fig:coneCrossSection}
\end{figure}

A cross-section of the primary axle and cone is shown in Figure \ref{fig:coneCrossSection}. As this is a hollow cone, calculate the moment of inertia for a solid cone of these dimensions and then subtract the moment of inertia of the material that is not present in this cone.
The moment of inertia of a solid truncated cone can be calculated by integrating the thin circular disks that make up the cone:
$$I_{solid} = \int_0^h \rho \frac{r(x)^2}{2} \text{d}V = \frac{\rho \pi }{2} \int_0^h r(x)^4 \text{d}x =\frac{\rho \pi }{2} \int_0^h \left( R_1 + \frac{R_2-R_1}{h}x \right)^4 \text{d}x $$
$$I_{solid} = \frac{\rho \pi h }{10}\left( \frac{R_2^5-R_1^5}{R_2-R_1}\right)$$
where $\rho$ is the density of the material, $h$ is the height of the cone, $R_1$ and $R_2$ are the radii at the two ends. Using the dimensions of the cone from Section \ref{sec:dimensions}:
$$I_{solid} = 0.0156~\text{kgm}^2$$

To get the moment of inertia of the hollow cone two sections must be removed, a cylindrical one at the base of the cone and another truncated cone at the narrower part, the total moment of inertia of these two shapes is: $I_{extra} = 7.27\cdot 10^{-3}$ kgm$^2$, so the hollow cone's moment of inertia:
$$I_{cone} = 8.33\cdot 10^{-3}~\text{kgm}^2$$

The moment of inertia of the hollow shaft that goes through the cone can be calculated in a similar way: 
$$I_{shaft} = 1.64\cdot 10^{-5}~\text{kgm}^2$$ 

The balls inside the carriage have a diameter of 25 mm, so their moment of inertia is:
$$I_{ball} = 1.64\cdot 10^{-8}~\text{kgm}^2$$
This is 5 orders of magnitude smaller than the moment of inertia of the cone-shaft assembly, it's contribution is not included in the model along with the moment of inertia of the load cell's rotating components, the rotor of the DC motor and the spring.


\subsection{Method and program}


\subsection{Data processing}

\subsection{Collected data}

\subsection{Curve fitting}

\subsection{Comparison with static friction}

\subsection{Conclusions}


\section{Risk assessment retrospective}

\printbibliography

\clearpage

\section*{Appendix A: Static friciton data}


\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-120, op.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-120, op.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-120, op.png}
    \end{minipage}

\end{figure}
\end{document}
