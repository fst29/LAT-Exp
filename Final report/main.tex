\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage[a4paper, 
            top=2.5cm, 
            bottom=2.5cm,
            right=2.5cm,
            left=2.5cm]{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{changepage}
\usepackage[sorting=none]{biblatex} %Imports biblatex package
\usepackage{titlesec}
\addbibresource{references.bib}
\counterwithin{figure}{section}
\counterwithin{table}{section}
%\titlespacing*{\section}
%{0pt}{2.2ex plus 1ex minus .2ex}{1.3ex plus .2ex}
%\titlespacing*{\subsection}
%{0pt}{1.4ex plus 1ex minus .2ex}{0.6ex plus .2ex}

%background: 5
%software: 10
%init: 2
% static fric: 10+3data
% dyn fric: 10+3data
%
%
%


\author{Flórián Tiefenbeck (fst29)}


%\topmargin 0.0cm \oddsidemargin 0.0in \evensidemargin 0.0in
%\textheight 25cm \textwidth  17cm \headheight 0in \headsep 0in
\parindent 0in
%\parskip \bigskipamount
%\pagenumbering{gobble}
\begin{document}
\pagenumbering{gobble}
\begin{center}
%{\Huge \bf Final report}\\
%\vspace{6pt}
{\LARGE \bf Experimental testing and modelling of a continuously variable transmission}\\
\vspace{4pt}
{\LARGE Flórián Tiefenbeck (fst29, Peterhouse)}\\
%{\LARGE Michelmas, 2023 }
\end{center}

\section*{Technical abstract}
\subsection*{Background and motivation}
\begin{wrapfigure}{R}{0.4\textwidth}
    \vspace{-\intextsep}
    \centering
    \includegraphics[width=0.35\textwidth]{conesPhoto.jpg}
    \\A picture of the continuously
    \\variable transmission
\end{wrapfigure}


This project focuses on a novel continuously variable transmission system. The system has two counterrotating cones and a carriage that transfers the torque between them with the use of two steel balls. During the project the different sources of power losses were measured and analysed with the aim of developing an experimental model of the system that can describe its operation. This model describes both the static case when the transmission starts moving and the dynamic case. The model allows comparison with other continuously variable transmission systems and makes it possible to improve this system by finding the sources of losses.\\


\subsection*{Methods}
Three major experiments were conducted during the project. The first one was the static friction test. The torque required to get the transmission moving at different positions and gear ratios were measured. The second experiment focused on the dynamic friction within the system. The final major experiment focused on the power losses in the system when it is under load.\\

The torque values were measured using a load cell built into the system and the positions and velocities were measured by encoders mounted on the motors and the output shaft.\\

A Raspberry Pi connected to the transmission was used to collect and analyse the data. Two main programs were created during the project, a backend program to control the motors and collect the sensor data and a frontend that creates an easy-to-use interface on the touchscreen, which can be used to control the apparatus and start the experiments. Some other, smaller programs were also created to process the recorded data.
\clearpage
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{manualPage.png}
    \\ The touchscreen interface
\end{figure}

\subsection*{Results}
Overall the theoretical model proposed at the start of the project to describe the relationship between the friction and the gear ratio was found to be accurate. The recorded data shows that the friction is highly dependent on the angular position of the shafts in both the static and the dynamic cases. This means that the power losses are not constant over a single revolution. \\

The created model can be used to find the dynamic or the static friction at a given carriage position, input shaft position and output shaft position using a simple formula. The model's friction curves are shown below.

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{BothF1.png}
         \centering
         \\Friction curves of the primary shaft
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{BothF4.png}
         \centering
         \\Friction curves of the secondary shaft
    \end{minipage}

\end{figure}




\pagebreak
\clearpage
\pagenumbering{arabic}
 \begin{multicols}{2}{\small \tableofcontents}\end{multicols}

\clearpage
\section{Background}
\label{sec:background}
The design was conceived during a project where Tryphon T. Georgiou, Faryar Jabbari and Malcolm C. Smith were trying to create a losslessly adjustable inerter and a losslessly adjustable spring. \cite{8718377} These are devices where the inertance or the spring constant can be changed during operation without any energy input. Their research was motivated by the ubiquity of variable dampeners commonly used in the auto industry. Linear devices were investigated initially such as the one shown in Figure \ref{fig:linvarspring}. This device has two terminals at (0,0) and ($x_1$, 0) where a force $F$ is applied. $k_0$ is a regular spring that has one end held stationary at (0, $y_0$) with the other end constrained to move in the $x$ direction. This end is connected to a lever that can pivot around the fulcrum at ($x_r$, $y_r$). If this fulcrum point is movable, a lossless adjustable spring is realised as shown in \cite{8718377}. A possible realisation of this system is shown in Figure \ref{fig:linvarspring_physical}. The lever and the wheel can rotate along the vertical axis passing through the contact point of the wheel. The wheel is also allowed to freely rotate along a horizontal axis, thus moving the fulcrum along the length of the lever. 


\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Linear varspring.png}
    \caption{The linear varspring design}
    \label{fig:linvarspring}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{lin_varspring_realisation.png}
    \caption{A possible physical realisation of the linear varspring }
    \label{fig:linvarspring_physical}
\end{figure}

Later during their project, rotating devices were considered. This eliminates the problem caused by physical limits and saturation of the system (shown in \cite{LUCAS}). The two-cone design in Figure \ref{fig:transmissionSchematic} was thus created. Attaching a spring or an inerter to one side of the transmission creates the losslessly adjustable device as desired. 





\subsection{Motivation}
As this is a new design, its operational parameters are generally unknown. In order to quantitatively compare it to other continuously variable transmission designs, these must be measured. This project aims to measure the most important parameters, such as the friction during operation or the power losses in the system. These measured values are then used to create an empirical model of the non-ideal system. 


\subsection{Design and Operation}

\subsubsection{Transmission}
The main part of the transmission consists of two counterrotating cones on two parallel shafts. The cones are facing in the opposite direction so that the distance between their surfaces remains constant. A carriage is suspended between the two cones, that is free to move along the length of the cone surfaces. The carriage holds two metal balls that are in contact with the cones and each other. They can rotate freely in any direction, allowing torque to be transmitted from one shaft to the other.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{georg5-2917853-large.png}
    \caption{Schematic of the transmission}
    \label{fig:transmissionSchematic}
\end{figure}

\subsubsection{Operation}
The position of the carriage is described using a number called the $p$-value. The definition of the $p$-value:
$$p=\frac{\text{cone diameter at the contact point between the secondary cone and the ball}}{\text{cone diameter at the contact point between the primary cone and the ball}}$$ 



The operation of the transmission can thus be described using two equations:

$$T_1=pT$$
$$\omega_1=\frac{\omega}{p}$$

These relationships ignore all friction and slip within the system.

\subsubsection{Auxiliary components}
\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{IMG_20231115_142939 resized.jpg}
    \caption{A photo showing the transmission and the auxiliary components}
    \label{fig:photo}
\end{figure}

The primary shaft of the transmission is driven by a Talon FX Falcon 500 brushless DC motor. This motor has a built-in controller and an encoder that can measure the shaft position. To eliminate issues caused by shaft misalignment, the shaft of the transmission is connected to the motor shaft through an Oldham coupling.\\ 

A digital load cell is built into the system between the coupler and the motor. This measures the input torque of the transmission system.\\

A rod extends from the freely moving carriage outside the enclosed part of the system, where it ends in a rack. A second Falcon 500 motor is mounted above this rack with a gear on its axle. This motor is used to move the carriage and thus change the $p$-value of the transmission system.\\

A Raspberry Pi 3 is used to control the apparatus and record measured data. The Pi is connected to a 10-inch touchscreen which can be used to provide instantaneous feedback from the transmission. The screen is also used to input commands and start the experiments.\\

These motors use the CAN protocol to communicate with the Raspberry Pi. This is a two-wire protocol widely used in the automotive industry that allows multiple devices to communicate using just one pair of wires. A USB-CAN adapter is utilised to connect the motors to the Raspberry Pi.\\

The position of the carriage and the position of the primary shaft can be measured by the encoders within the motors, but the position and velocity of the secondary shaft cannot. A standalone encoder, an RE30E1024-213-1 from Nidec Components \cite{encoder}, is connected to the secondary shaft to overcome this issue. The encoder is connected to the shaft with a gear so that the encoder axle rotates four times faster than the secondary shaft. The encoder is powered directly from the Raspberry Pi and its output wires are also connected to the GPIO headers on the Pi.\\

The secondary shaft is also attached to a torsional spring that can be used to simulate loads on the system. The other end of the spring can either be held stationary by a clamp or released to rotate freely if no load needs to be simulated. If the spring is connected, the system behaves as a lossless varspring described in Section \ref{sec:background}.\\




%\subsection{Dimensions}

\subsection{Use cases of a CVT}
Continuously variable transmissions are useful in applications where two shafts with different preferred rotational speeds have to be coupled in a way that can accommodate a change in these speeds.\\

A very common application is in the automotive industry, internal combustion engines have a narrow RPM range where they are the most efficient but as the car's speed changes a conventional transmission system is not always able to keep the engine speed within range.\\

Wind turbines are another possible area, in turbines where synchronous generators are used, the generator's rotational speed is kept constant by the grid frequency. On the other hand, the turbine blades can extract energy from the moving air most efficiently when their speed is at a certain tip-speed ratio \footnote{The tip speed ratio is the ratio between the speed of the turbine blade's tip and the wind speed.}, which depends on the geometry of the blades as shown in Figure \ref{fig:windTurbine}. To keep the turbine in this efficient regime at all times, a continuously variable transmission can be used.


\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{Cp-vs-Lambda-characteristics-for-various-blade-pitch-angle.png}
    \caption{The efficiency of a wind turbine against tip speed ratio \cite{wind}}
    \label{fig:windTurbine}
\end{figure}


\subsection{Comparison to other CVT designs}
In other designs, such as the pulley-based CVT shown in Figure \ref{fig:pulleyCVT} or the Evans CVT \cite{evans} shown in Figure \ref{fig:evans}, a frictional force must be overcome to change the torque ratio. Here the balls can rotate freely along the surface of the cone so no energy input is needed.\\

An other benefit compared to some other designs is the ability to change the torque ratio when the transmission system is stationary. This CVT can also transmit torque in both directions. \\

A possible drawback compared to some other CVT systems and regular automotive transmissions is that the CVT cannot change the direction of rotation. This means that an other system is also required for automotive applications.

\begin{figure}
    \centering
    \begin{minipage}{0.49\textwidth}
        \includegraphics[width=\textwidth]{Pulley-based-CVT-04.png}
        \caption{Pulley-based CVT \cite{pulleyCVT}}
        \label{fig:pulleyCVT}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \includegraphics[width=\textwidth]{evans.png}
        \caption{Evans CVT \cite{evans}}
        \label{fig:evans}
    \end{minipage} 


\end{figure}


\pagebreak
\section{Software design}
All of the software used to control the experiments or manually move the motors was written during this project. There are two main programs running on the Raspberry Pi during operation. One is communicating with the sensors and the motors (backend) and the other is communicating with the user (frontend). This separation allowed two different programming languages to be used for the two programs, so the strengths of each language could be utilised.

\subsection{Backend}
The backend program is written in the C++ language. This was chosen for two reasons, the first is the inherent speed of the language as it is a compiled language. This allows the program to run at high speeds even on such relatively weak hardware as the Raspberry Pi. This enabled higher sampling frequencies to be used and finer control of the motors. The other reason for choosing this language was the availability of the official motor control library created by the manufacturers of the motors. This library makes interfacing with the motors a much simpler task by creating an abstraction layer. This means that in the backend program simple commands can be used to control the motors, which are then translated to the more complex low-level instructions by the library.\\

The backend program has two main parts, first a setup part that runs once on startup, then a loop that runs until the program is stopped. The setup part establishes the connection with the motors, sets up the secondary encoder, initialises the message reader and creates the file that is used to save all the measured data. The loop part has three main tasks, it collects measurements, sends commands to the motors and saves the collected data to the output file.  


\subsubsection{Motor setup}
The motor setup utilises functions from the aforementioned motor library. Initially, communication is established with the motors using the CAN bus adapter. Once a stable link is created, the PID parameters, the maximum torque, the maximum speed, the maximum acceleration, the internal loop frequency, and the maximum current draw are set. Most of the values used here were determined before this project and were not changed.

\subsubsection{Secondary encoder}
The encoder on the secondary shaft is connected directly to the Raspberry Pi using the GPIO headers. The encoder is an incremental quadratic type, which means it has two outputs (A and B) which change as shown in Figure \ref{fig:encoder}. At each encoder tick (corresponds to 1/1024 of a full rotation of the encoder, equal to 1/(1024*4) of a full rotation of the secondary shaft) one of the two signals changes. By treating the encoder as a two-bit state machine a state transition table can be created as shown in Table \ref{tab:output_encoder}.\\
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
        Previous  & Current  & Movement&Value of & Value in \\
        state (A\textsubscript{n-1}B\textsubscript{n-1}) & state (A\textsubscript{n}B\textsubscript{n})&&\verb|output_encoder_state|& lookup table\\%\verb|state_transition_matrix| \\
        \hline
         00&00&None&0000\textsubscript{2}=0\textsubscript{10}&0\\ 
         00&01&CCW&0001\textsubscript{2}=1\textsubscript{10}&+1\\ 
         00&10&CW&0010\textsubscript{2}=2\textsubscript{10}&-1\\ 
         00&11&Error&0011\textsubscript{2}=3\textsubscript{10}&0\\ 
         
         01&00&CW&0100\textsubscript{2}=4\textsubscript{10}&-1\\ 
         01&01&None&0101\textsubscript{2}=5\textsubscript{10}&0\\ 
         01&10&Error&0110\textsubscript{2}=6\textsubscript{10}&0\\ 
         01&11&CCW&0111\textsubscript{2}=7\textsubscript{10}&+1\\ 
         
         10&00&CCW&1000\textsubscript{2}=8\textsubscript{10}&+1\\ 
         10&01&Error&1001\textsubscript{2}=9\textsubscript{10}&0\\ 
         10&10&None&1010\textsubscript{2}=10\textsubscript{10}&0\\ 
         10&11&CW&1011\textsubscript{2}=11\textsubscript{10}&-1\\ 
         
         11&00&Error&1100\textsubscript{2}=12\textsubscript{10}&0\\ 
         11&01&CW&1101\textsubscript{2}=13\textsubscript{10}&-1\\ 
         11&10&CCW&1110\textsubscript{2}=14\textsubscript{10}&+1\\ 
         11&11&None&1111\textsubscript{2}=15\textsubscript{10}&0\\ 
         \hline
    \end{tabular}
    \caption{State transition table of the secondary encoder (Note that the actual values of the lookup table are scaled to give result in degrees)}
    \label{tab:output_encoder}
\end{table}

During this part of the program interrupts are attached to the two encoder pins. These interrupts call the same function ( \verb|encoder_callback()|) if one of the signals changes in either direction.

A global variable called \verb|output_encoder_state| is also created, this is a four-bit number that represents the current and the previous state of the encoder signals in the format (in binary) A\textsubscript{n-1}B\textsubscript{n-1}A\textsubscript{n}B\textsubscript{n}. \\

A lookup table (\verb|state_transtion_matrix|) is also created from the state transition table shown in Table \ref{tab:output_encoder}. It has 16 elements corresponding to each possible transition, the positive transitions have a value of +1, the negative transitions have a value of -1 and the entries corresponding to no movement or error have a value of 0. After creating the table, its values get scaled by 360/(1024*4) to get the result in degrees.\\

When the callback function is called, \verb|output_encoder_state| gets bit-shifted left by two bits and bitwise ended with 1100, effectively moving the "current" measurement to the location of the previous and deleting the previous. After the shift, the lower two bits get populated with the new values of the encoder output. The last step of the callback function is to add the value of the state transition matrix to the variable that stores the position of the secondary shaft. This is implemented by adding the \verb|output_encoder_state|-th element of the \verb|state_transition_matrix| array to the position variable.

Using these bitwise operations and the lookup table allows the callback function to be executed very quickly. This is important as this is an interrupt so the rest of the program is halted while this runs.




\begin{figure}[!h]
    \centering
    \includegraphics[width=0.8\textwidth]{encoder_waveform.png}
    \caption{The output waveforms of the encoder, Figure from \cite{encoder}}
    \label{fig:encoder}
\end{figure}



\subsubsection{Message reader}
During the setup phase a second thread is started. On this thread a loop is running, that checks the specified named pipe for new commands. If no message is received, this thread waits until a message is sent by the frontend. When it detects a message, it reads it into memory and calls two functions to convert the raw text into usable commands. Each message has a keyword that specifies the action and, depending on the keyword, some numerical arguments delimited by spaces. The first function is \verb|get_command()|, which extracts this keyword from the message. The second function (\verb|get_command_vaues()|) is used to extract the arguments from the message. These extracted values then get stored in global variables that can be read by the main loop of the program running on the other thread. 


\subsubsection{Output file}
\label{sec:outputFile}
As the last step of the setup, the log file is created. This .csv file stores all the data collected by the Raspberry Pi during the experiments. The name of this file is the current date and time. At this point, the first row is filled with the following columns: Time (HH:MM:SS), Milliseconds, Command, State, DrivePosTarget, DriveRatioTarget, Drive position, Drive velocity, Drive current, CarriagePosTarget, Carriage position, Carriage velocity, Carriage current, Output position, Output velocity. At each iteration of the main loop a new row is added to the file with the data.



\subsubsection{Timing of the loop}

Two methods of timing the main loop were tested during this project as shown in Figure \ref{fig:timings}. The first method uses an infinite loop running constantly and checking the elapsed time in every iteration, if the time since the last execution exceeds the set time, the main part of the program is entered, where measurements are taken, the motors are controlled and data is saved. This approach would work well on systems without an OS, where only one program is running at a time. Here, where several other programs are trying to use the CPU at the same time, constantly checking for the time elapsed is not a good solution as it uses up resources and slows down other programs.\\

The second also uses an infinite loop but instead of checking the time in every iteration, the thread is put to sleep after each iteration. To achieve accurate timings, the execution of the main part is measured and the sleep time is set, so that the thread sleeps for the remainder of the loop time. If the execution of the main part takes longer than the predefined loop time, an error is shown.
Changing to the second option fixed problems which led to unexpected crashes of the program. No difference in timing accuracy could be measured between the two methods.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Timing.drawio.png}
    \caption{The two methods of timing the main loop}
    \label{fig:timings}
\end{figure}



\subsubsection{Collecting measurements}
The first part of the loop deals with measurements, the \verb|get_measurements| function is called. Within this function the current time from the system clock is saved to provide a timestamp for the measurement. Then communication with the motors is initiated over the CAN bus to request the latest position, velocity and current measurement from the motors' internal systems. The received values are converted to degrees in the case of the drive motor and $p$-value in the case of the carriage motor. The received values are saved in variables that will later be used for control and logging. At this stage, a measurement message is prepared in the format specified in Section \ref{sec:measurements}. The formatted message is then written to the named pipe for the frontend to read.




\subsubsection{Executing commands}
Two types of commands have been used during this project, a simple command that takes one iteration of the loop to execute and complex commands that take several loops. 
\begin{table}[]
    \centering
    \begin{tabular}{|l|l|}
         \hline
         \textbf{Simple commands}&\textbf{Complex commands}  \\
        \hline
         \verb|STOP| (0)&\verb|INITIALISE_DRIVE| (0)\\
         \verb|CARRIAGE_GOTO| (1)&\verb|INITIALISE_CARRIAGE| (0)\\
        \verb|DRIVE_GOTO| (1)&\verb|STATIC_FRICTION| (0)\\
        \verb|CARRIAGE_SET_POS| (1)&\verb|DYNAMIC_FRICTION| (0)\\
        \verb|DRIVE_SET_POS| (1)&\verb|SPRING_CHARACTERISATION|\\
        \verb|OUTPUT_SET_POS| (1)&\\
        \verb|PID_DRIVE| (4)&\\
        \verb|DRIVE_SINE| (4)&\\
        \verb|CARRIAGE_SINE| (4)&\\
        \verb|BOTH_SINE| (8)&\\
        
        \hline    
    
    \end{tabular}
    \caption{The possible commands with the amount of parameters in parantheses}
    \label{tab:my_label}
\end{table}\\

\verb|STOP|\\

When this command is received, the supply of the motors is removed so they come to a stop.\\

\verb|CARRIAGE_GOTO| and \verb|DRIVE_GOTO| \\

These commands can be used to set the carriage to a desired $p$-value and to move the primary shaft to a specified position. The arguments sent with these functions is the desired $p$-value and the final position in degrees. Both commands use the motor controller's built-in 'MotionMagic' controller. This generates a smooth velocity profile between the current position and the final position with predefined acceleration and maximum velocity values. \\

\verb|CARRIAGE_SET_POS|, \verb|DRIVE_SET_POS| and \verb|OUTPUT_SET_POS|\\

These commands can be used to overwrite the stored encoder positions. These are useful after restarting the program, as the encoder positions are reset to 0 after each restart.\\

\verb|DRIVE_PID|\\
The four parameters of this command: $k_p$, $k_i$, $k_d$ and $k_f$. When this command is received the values are sent to the built-in motor controller to change the PID tuning of the drive motor. This was not used during the project.\\

\verb|DRIVE_SINE|, \verb|CARRIAGE_SINE| and \verb|BOTH_SINE|\\
When this command is executed, the drive motor, the carriage motor or both are driven in a sinusoidal pattern with the specified amplitude ($A$), offset ($\theta_0$), frequency ($f$) and phase ($\phi$). The motion can be described by the following relationship: 
$$\theta(t) = \theta_0 + A\sin(2\pi ft +\phi)$$
where $t$ is the time of the system's clock.\\

The defining feature of complex commands is that their execution spans over several loops of the program and they have several execution stages. The \verb|state| variable is utilised to keep track of the currently executed part of the command. The \verb|posTarget| and \verb|ratioTarget| variable is used to store a calculated target position or target torque (as a percentage of maximum torque) that is to be used during the next iteration. These variables are saved along with other data into the log file. A detailed explanation of the execution of the complex commands is included in their relevant sections.
 


\subsubsection{Saving data}
After the command has been executed, the next row of the log file is filled with data. Each row contains the timestamp recorded when the measurements were taken. The currently active command and its state are included as well as the other measured values listed in Section \ref{sec:outputFile}. 


\subsection{Frontend}
The frontend is made using the Python language and the Tkinter GUI module. The language was selected because it is a high-level language that enables quick development. The main drawback of the language is its relatively slow execution time but this is not relevant for a user interface. The Tkinter module makes GUI development simpler by adding pre-built interface elements, such as buttons or textboxes. These can be configured and placed in the window to build up the user interface. The module also offers touchscreen compatibility, which is required here. 

Visually the window is split vertically into two sections. The upper part contains the numpad and measured data display area. The lower part is used to control the apparatus with different commands split across the different tabs.

The frontend utilises two threads, just like the backend. The first thread is responsible for the received messages from the backend and the other thread handles the input from the user and sends it to the backend.


\subsubsection{Numpad}
As the Raspberry Pi is not connected to a keyboard, the only way to input numbers was the on-screen keyboard of the operating system. Using this proved to be cumbersome as this is a full keyboard that takes up most of the screen. During operation only numerical data needs to be entered, therefore a numpad was included in the user interface, which is always visible and enters numbers into the selected textbox. The numpad contains the numbers 0-9, a decimal point, a negative sign and a backspace key. Switching from the OS's keyboard to this numpad made using the GUI significantly faster.


\subsubsection{Measurement display area}
This area remains visible at all times and shows the position and velocity of all encoders, the current draw of both motors and the active command and its state are also displayed. This area is updated using the first thread of the frontend, where an infinite loop is running, which checks for a message coming from the backend in each iteration. If no message is received it halts until a message appears. When a message is received it checks whether the format of the message is correct and raises an error if it isn't. In the next step, the data is extracted from the message and the text displayed in the measurement display area gets updated. The layout of the measurement display area is shown in Figure \ref{fig:manual}.

\subsubsection{STOP button}
A stop button is also visible on the GUI at all times. This can be used to quickly stop the movement of all motors.


\subsubsection{Manual page}
The first page that comes up when the program is started is the manual page shown in Figure \ref{fig:manual}. On this page both motors can be driven manually to a position. There are also buttons to move the driveshaft or the carriage a small amount (5° or 0.1 $p$) in either direction. On this page the measured position can be overwritten manually. This is necessary if the program is restarted, as the encoders can only measure the change in position, not absolute position. If the position is known it can be entered on the manual page, if it is not, the initialisation algorithms (Section \ref{sec:initialisation}) can be used to determine the position.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{manualPage.png}
    \caption{The measurements display area with the manual page of the GUI}
    \label{fig:manual}
\end{figure}

\subsubsection{Experiments page}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{experimentsPage.png}
    \caption{The experiments page of the GUI}
    \label{fig:experimentsPage}
\end{figure}
The experiments page of the GUI is shown in Figure \ref{fig:experimentsPage}. Each preprogrammed experiment and the initialisation algorithms can be started on this page. The dynamic friction experiment's parameters can also be entered on this page.

\subsubsection{Sinusoidal page}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{sinusoidalPage.png}
    \caption{The sinusoidal page of the GUI}
    \label{fig:experimentsPage}
\end{figure}
The parameters of the sinusoidal movement can be entered on this page.

\subsubsection{PID page}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{pidPage.png}
    \caption{The PID setup page of the GUI}
    \label{fig:experimentsPage}
\end{figure}
A page was created, where the PID parameters of the drive motor can be changed quickly. This was not used during the project as the parameters determined before this project were used.


\subsubsection{Sending commands}
When a button is pressed on the GUI a command is written to the named pipe named \verb|commands| in the format specified in Section \ref{sec:commands}. If the command requires parameters, an additional check is performed. The parameters are checked to make sure that they are valid numbers within specified limits.

\subsubsection{Receiving measurements}
The second thread of the frontend is reading the \verb|measurements| named pipe. When a new message is sent by the backend, a function decodes the message and extracts the numerical values. When this is done, the values on the GUI are updated.

\subsection{Communication}
Communication between the two programs is accomplished using named pipes \cite{MKFIFO}. This is a built-in system found in Unix-like operating systems (such as the Raspberry Pi OS) that allows the creation of a pipeline that two separate programs can read simultaneously. These pipes can be read and written to just like regular files except that when a message on a named pipe is read, it is also removed from the pipe.\\

Two other methods were investigated: regular files and shared memory addresses. The main drawback of regular files is that only one process can open it at a time, so the reader would have to open the file and check for changes regularly. This leads to problems when the writer tries to send a message when the reader has the file open. Named pipes don't have this problem as both processes can open the file at  the same time.\\

Shared memory addresses do offer higher data throughput but since the amount of data transmitted here is relatively low, this is greatly outweighed by the ease of setting up named pipes. 


\subsubsection{Commands}
\label{sec:commands}
Commands are sent from the frontend to the backend. A single transmission always carries one command. The command consists of a keyword followed by some parameters (some keywords do not need parameters). The parameters are formatted as floating point numbers and they are separated from the keyword and the other parameters by spaces. A possible command message is shown in Figure \ref{fig:commandMessage}. This command would cause the drive motor to move in a sinusoidal motion with an amplitude of 20°, a frequency of 1.4 Hz, a 45° phase and a 10° constant offset.\\

Keeping the keywords and the numbers in this human-readable format makes it possible to read these messages with other programs, which makes debugging easier. It also allows other programs to emulate the behaviour of the frontend by writing to this named pipe by hand. This way the backend can be used without the frontend. 

\begin{figure}[h]
    \centering
    \verb|DRIVE_SINE 20 1.4 45 10|
    \caption{An example command}
    \label{fig:commandMessage}
\end{figure}


\subsubsection{Measurements}
\label{sec:measurements}
Measurements are sent from the backend to the frontend. Here a single transmission holds all the data measured at a timestamp. Each measurement is transmitted as a name-value pair separated by a space, the pairs are also separated by spaces. While transmitting the names with every transmission is not strictly necessary, (the decoder could decode the message without it, as the order of measurements is always the same) it is kept included so that the sent message can be read without a preprogrammed decoder. Including the names allows an extra check to be performed on the data to check its integrity which would be more difficult if the message only contained a list of numbers. Figure \ref{fig:measurementMessage} shows a possible measurement message.

\begin{figure}[h]

    \verb|CARRIAGE_POSITION 1.43 CARRIAGE_VELOCITY 0 CARRIAGE_CURRENT 0.0|
    \verb|DRIVE_POSITION -12.3 DRIVE_VELOCITY  13.1 DRIVE_CURRENT 4.2|
    \verb|OUTPUT_POSITION 44.1 OUTPUT_VELOCITY 9.0 COMMAND DYNAMIC_FRICTION|
    \verb|STATE moving_positive|
    \caption{An example measurement message}
    \label{fig:measurementMessage}
\end{figure}

\clearpage
\section{Initialisation algorithms}
\label{sec:initialisation}
All the encoders used on the apparatus are incremental encoders which means that they only measure a change in position, they cannot measure absolute position. Before an experiment can begin the current position of the shafts and the carriage must be entered through the interface's manual tab. If the position is not known, the following methods can be used to initialise the encoders.

\subsection{Primary shaft}
The primary shaft does not have any features that would allow a program to find the zero position automatically. Instead, an eyepiece with a line on it is mounted above the shaft. When this line is aligned with the line on the primary shaft, the shaft is at the 0° position. This eyepiece was added to the transmission system as a part of this project. This involved choosing the right eyepiece and designing the mount for it (shown in Figure \ref{fig:eyepieceMount}). This mount was then manufactured by the technicians of the department. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{Eyepiece_mount.png}
    \caption{The CAD model of the eyepiece mount}
    \label{fig:eyepieceMount}
\end{figure}



\subsection{Secondary shaft}
If the absolute position of the secondary shaft is not known, it can be found using the endstops, the 0° position is defined to be halfway between the two endstops. This initialisation can be accomplished by a premade algorithm that can be started on the touchscreen interface. Initially, the system is slowly driven in the positive direction at a low torque level. In every loop the velocity is checked, if it falls to zero, it is assumed that the output shaft has hit the endstop. This position is saved and the drive is driven in the negative direction. When it stops again, the other endstop's position is saved and the zero position is calculated. Finally, the output shaft is moved back to the 0° position. The algorithm is shown diagrammatically in Figure \ref{fig:driveInit}.\\

The main difficulty encountered during the implementation of the algorithm was the tuning of the speed. If it is set too low, the shaft could get stopped before it actually reaches the endstop due to the changes in friction. On the other hand, if it is set to a too high value, the output shaft slams forcefully into the endstop which could damage the components. 


\begin{figure}
    \centering
    \includegraphics[width=0.2\textwidth]{DriveInit.drawio.png}
    \caption{The initialisation algorithm of the secondary shaft}
    \label{fig:driveInit}
\end{figure}


\subsection{Carriage}
The carriage also lacks any easily identifiable features that could be used for initialisation. It does not have purpose-made endstops, its movement is only limited by the enclosure. The option of using this to find the absolute position was considered but eventually not used because neither part was designed to handle impacts like this. Repeatedly hitting the walls of the enclosure could damage the carriage or cause it to get out of alignment.\\

The position of the carriage is instead measured indirectly by measuring the $p$-value using the relative movement of the two shafts. At two different carriage positions the primary shaft is moved 50° from its starting position, the displacement of the secondary shaft is measured and thus the $p$-value can be calculated. Measuring the $p$-value at two different positions allows the change in $p$ per encoder tick to be calculated using the fact that the $p$-value changes linearly with the carriage position, which is also directly proportional to the rotation of the carriage motor. 
 

\pagebreak
\section{Static friction}
\subsection{Motivation}
An important part of the model that describes the CVT is the torque needed to get the shafts moving from a stationary position. It is expected that the torque required at this stage is somewhat higher than the dynamic friction during continuous movement. This part of the project aims to characterise the friction and its dependence on the $p$-value. During initial tests it was found that the static friction also depends on the angular position of the cones, this dependence is also analysed. 





\subsection{Static friction model}
\label{sec:staticFricTheory}



\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Static friction model wo RR.drawio.png}
    \caption{The static friction model}
    \label{fig:staticFricModel}
\end{figure}

Figure \ref{fig:staticFricModel} shows a model of the transmission system with the forces and torques acting on the components shown. Torques labelled $F_i$ are the limiting static friction torques acting in the bearings of the shafts and the balls, the rolling resistance is also incorporated into these torques (see Section \ref{sec:rollingFric}). Forces labelled $I_{i-j}$ are the static friction forces acting between the components, these forces carry the torque through the system. $T_{\text{motor}}$ is the torque of the motor that drives the primary shaft, as the spring is disconnected during this experiment, there is no torque acting on the secondary cone other than the friction in its bearings and rolling resistance. \\

As none of the components move at this point, the forces and torques shown in Figure \ref{fig:staticFricModel} must balance until static friction is broken. In order to refer forces and torques between components, their radii must be known, let $R_1$ and $R_2$ be the radius of the primary and secondary cones  respectively at the contact points and let the radius of the balls be $R_b.$\\

Equating the forces and torques starting from the secondary cone:\\

$$I_{3-4} = \frac{F_4}{R_2}$$

$$I_{2-3} = I_{3-4}  + \frac{F_3}{R_b} = \frac{F_4}{R_2} + \frac{F_3}{R_b}$$

$$I_{1-2} = I_{2-3} + \frac{F_2}{R_b} = \frac{F_4}{R_2} + \frac{F_3}{R_b}  + \frac{F_2}{R_b}$$

$$T_{\text{motor}} = R_1 I_{1-2} + F_1 = F_1 + R_1 \left(\frac{F_4}{R_2}  + \frac{F_3}{R_b}  + \frac{F_2}{R_b} \right) $$

To simplify this equation the definition of the $p$-value can be used:
$$p=\frac{R_2}{R_1}$$

Also, since the cones are aligned in a way so that $R_1+R_2 = R_1(1+p)$ is a constant, the relationship between $R_1$ and $R_b$ can be expressed in terms of $p$:
$$\frac{R_1}{R_b} = \frac{c}{(1+p)}$$
where $c$ is a constant.
Using these equations, the torque of the motor in the static friction case can be expressed as:
$$T_{\text{motor}} = F_1 + \frac{F_4}{p} + \frac{c(F_2+F_3)}{1+p}$$

Initially, the values of $F_i$ were assumed to be constant, so that the motor torque required to get the system moving would only depend on the $p$-value. This assumption turned out to be false, as the friction torque exhibits a strong dependence on the angular position of the shafts. To characterise these variations, it is assumed that $F_1$ depends on the angle of the primary shaft ($\theta_1$), while $F_4$ depends on the angle of the secondary shaft ($\theta_4$).



\subsubsection{Modelling rolling friction}
\label{sec:rollingFric}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Rolling friction model.drawio.png}
    \caption{The model of rolling resistance used during the analysis}
    \label{fig:rollingFriction}
\end{figure}


As an object rolls over another their surfaces deform elastically and this causes elastic forces to arise between the two objects. These forces align in a way that they counteract the motion so they can be modelled using an offset net force as shown in Figure \ref{fig:rollingFriction}) This offset force is equivalent to a torque and a force, whose line of action passes through the centre of the rolling object. This allows the incorporation of the rolling friction into the torques $F_i$ above. The forces normal to the surfaces are not shown in Figure \ref{fig:staticFricModel}.   





\subsection{Method and program}

\begin{figure}[h]
    \centering
    \includegraphics[width=.3\textwidth]{StaticFriction.drawio.png}
    \caption{The flowchart describing the static friction program}
    \label{fig:staticFricFlowchart}
\end{figure}

The goal of this experiment is to measure the torque required to get the transmission system moving at different shaft positions and $p$-values. Initially, the drive motor torque is set to a low value and then it is increased slowly in several steps. If no movement is detected using the encoders, the torque is increased to the next level. A typical torque-time plot of the experiment is shown in Figure \ref{fig:staticFricTorqueTime}. If movement is detected, the position of both shafts and the $p$-value is recorded for later processing and the torque is reduced. After the transmission has moved to the next measurement position and it has stopped there, the process repeats.\\

The static friction is measured over the whole range of motion of the output shaft nine times, at three different $p$-values and at each $p$-value with three different shaft offsets. This makes it possible to separate the effect of the input shaft's static friction from the output shaft's static friction.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\linewidth]{staircase.png}
    \caption{The torque during the static friction test}
    \label{fig:staticFricTorqueTime}
\end{figure}

The algorithm that controls this experiment can be started using the "Dynamic Friction" button on the touchscreen GUI's experiments page. The experiment is run using a state machine with three states. When the program starts it is in the start state, here the starting position of both shafts get saved and the torque is set to 75\% of the previous peak. During the first few versions of the program the torque was always set to a predefined value but this led to very long ramp-up times when the transmission was in a high torque region. Using a fraction of the previous peak value as the next starting point speeds up the experiment significantly. This does not lead to measurement errors as the static friction torque does not change that much between neighbouring measurement points. \\

After the starting value has been calculated, the program moves to the ramp-up state. When the program enters this state it checks for movement of the transmission system by comparing the current encoder positions to the previously saved starting positions.  \\

If no movement is detected, a counter is incremented, this counter is used to create the steps of the staircase-like torque graph. When the counter value is smaller than 30 (corresponding to 300 ms) the current torque value is kept. When the counter reaches 30, the torque is increased by the predefined percentage step (0.1\% was used) and the counter is reset to 0.\\

If movement is detected, the motor torque is set back to zero and the program enters the cooldown state. At this point the program also checks whether the output shaft is getting close to its endstops, if that is the case the direction of movement is reversed.
The cooldown state is necessary as the motor current cannot change instantaneously, the coils of the motors need time to collapse their electric fields before the torque reduces. At this point the shaft is also moving so it has to be stopped before the next measurement cycle can begin. At every loop of this state the motor current and the speed of the shaft is checked, if both have fallen to zero, the program progresses to the start state and the next measurement is taken.


\subsection{Data synchronisation}
\label{sec:staticFricSyncing}
\begin{figure}[h]

    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing,1.png}
        
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing2.png}
        
    \end{minipage}

    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing3.png}
        
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{syncing4.png}
        
    \end{minipage}
    \caption{The three steps of the syncing process along with the variation of syncing error with offset}
    \label{fig:syncing}
\end{figure}



The data saved by the program made during this project attaches a timestamp with millisecond precision to every recorded datapoint. The data of the load cell that measures the torque of the motor is not recorded using this program, instead the cell's own application is used to record data. The datapoints recorded here also have a millisecond precision timestamp but in this case the timestamp only shows the time elapsed since the first measurement. While the timestamp of the first measurement does have an absolute date and time, this is only given to the nearest second. This means that while the timestamps are very precise, they are not accurate enough to be used without a synchronisation step.\\

To synchronise the two datasets, the current measurements (measured by the program written during the project) are compared to the torque measured by the cell's application. These two datasets were selected because they are linearly proportional in a DC motor. One of the "staircases' shown in Figure \ref{fig:staticFricTorqueTime} get selected in each dataset, the one second accuracy is good enough to easily identify a matching pair. When a pair is identified, they are scaled so that their peak value is the same, this creates two identical functions that are offset by some amount of time. One of these datasets are moved along the time axis until the squared difference between the two datasets is minimised. When this time offset factor is found, the whole dataset is shifted by this amount to achieve synchronisation.


\subsection{Data processing}
The synchronised torque data is then further processed using an other program written during this project. This program finds the peaks of these staircases and creates a new data file where the peak torque, the corresponding shaft positions and the carriage position are stored. This greatly reduces the amount of data that must be processed further and since for this experiment only the torque at which the transmission starts moving carries useful information, the deleted datapoints do not influence the final results. 


\subsection{Problems with movement detection}
The initial static friction tests produced data that is shown in Figure \ref{fig:beforeFix}.  

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{staticFrictionBeforeFix.png}
    \caption{Data collected using the old movement detection}
    \label{fig:beforeFix}
\end{figure}

In the Figure a clear trend is visible with most points being grouped very tightly around this line but some recorded static friction datapoints are below the rest. Further inspection of the collected data showed that when these points that do not follow the trendline have been recorded the transmission only moved 1 encoder tick (0.176°) on the primary side and then stopped again. Also no movement was detected on the secondary side. The original movement detection check only looked at the primary side so this was enough for the program to think that static friction was overcome. Further tests showed that the transmission system is able to elastically deform a small amount under the load without actually breaking static friction. If the system comes to rest close to the boundary between two encoder ticks, a very small amount of movement can move it to the next tick and cause a false movement detection.\\

The solution to this problem was a change to the movement detection, instead of triggering on a single tick change, the primary shaft has to move at least two ticks (0.352°) before the ramp-up is stopped and the static friction is considered broken. Additionally, movement at both the input and output shaft must be detected for the algorithm to trigger. This change has greatly reduced the number of these false positives. 



\subsection{Collected data}
The static friction was recorded at three different $p$-values and three different offsets, in total more than 4000 measurements were taken. Over a single run the static friction was measured every 0.75° along the axles. The collected static friction data has been plotted against the position of the input shaft and the position of the output shaft. Some of these plots are shown in Figure \ref{fig:staticFrictionData}. The data was plotted this way to identify whether the variation with position correlates with the position of one of the cones. This did not lead to any conclusion and later calculations showed that the friction depends on both shaft positions independently. At each position the friction was measured twice, once in the positive direction and once in the negative direction, these datapoints are shown in different colour.\\

The increased density of datapoints on the left side of the first plot in Figure \ref{fig:staticFrictionData} is due to the fact that the primary cone was in that position twice during the experiment. As $p>1$, the primary cone rotates more than the secondary cone, so it goes more than a full circle while the secondary shaft moves from one endstop to the other (around 330°). Similarly, on the plots where $p<1$, a gap is visible as the primary shaft does not go all the way around.
 
\begin{figure}[!h]
\label{fig:staticFrictionData}
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, op.png}
    \end{minipage}
\caption{Some of the static friction data collected}
\end{figure}



The data recorded at different $p$-values and different offsets are included in Appendix A.
The variation with $p$-value visible in the plots is expected, as the friction of the secondary shaft is referred to the primary. On the other hand, the dependence on the position is not explained by the simple model described above.










\subsection{Curve fitting}
\label{sec:staticFricCurve}
The next part of this project focused on modelling this positional dependence of the static friction. Quantifying the dependence of the static friction on the shaft positions and the $p$-value makes it possible to create a model that describes the operation of the transmission system. The model is based on the equation from Section \ref{sec:staticFricTheory}:
$$T_{\text{motor}} = F_1 + \frac{F_4}{p} + \frac{c(F_2+F_3)}{1+p}$$

It is assumed that $F_1$ varies with the position of the input shaft ($\theta_1$) and $F_4$ depends only on the position of the secondary shaft ($\theta_4$). The dependence of $F_2$ and $F_3$ on these positions was analysed but no correlation with either $\theta_1$ or $\theta_4$ was found so their sum was assumed to be constant. Two splines were considered for the friction values, a quadratic in the form:
$$F_i = a_i \theta_i^2 + b_i \theta_i + c_i$$
and a sinusoidal in the form:
$$F_i = a_i \sin\left( \theta_i + \phi_i  \right)  + c_i$$

The coefficients of the splines ($a_i$, $b_i$, $c_i$, $\phi_i$) were optimised using Scipy's \verb|curve_fit| function to achieve the lowest squared error between the measured data and the fitted curves. The value of the ball friction ($c(F_2+F_3)$) was also entered into the fitting process, the best-fit value is denoted $c_3$ in the tables below.\\

Table \ref{tab:staticFricCoeffs} contains the best-fit coefficients of the two curves and \ref{fig:staticFitCurves} shows the best-fit curves plotted against the shaft positions ($F_1$ against $\theta_1$ and $F_4$ against $\theta_4$).
 
\begin{table}[h]
    \centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{Quadratic}     & \multicolumn{2}{|c|}{Sinusoidal}    \\ \hline
$a_1$        & -2.59E-06 & $c_1$         & 2.19E-01 \\ \hline
$b_1$        & 6.15E-05  & $c_2$         & 1.28E-01 \\ \hline
$c_1$        & 2.46E-01  & $c_3$         & 1.01E+00 \\ \hline
$a_2$        & -2.98E-06 & $a_1$         & 3.86E-02 \\ \hline
$b_2$        & -1.22E-05 & $a_2$         & 3.86E-02 \\ \hline
$c_2$        & 1.58E-01  & $\phi_1$         & 83.1°\\ \hline
$c_3$        & 3.37E-01  & $\phi_2$         & 87.7° \\ \hline
\end{tabular}
    \caption{The best-fit coefficients.}
    \label{tab:staticFricCoeffs}
\end{table}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{StaticF1.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{StaticF4.png}
    \end{minipage}




\label{fig:staticFitCurves}
\caption{The best-fit $F_1$ and $F_4$ curves}

\end{figure}

The static friction can therefore be modeled as a single function of the shaft positions and the $p$-value using the following equations. (with $\theta$ in degrees)
If the quadratic fit is used:\\

$$F_{\text{total}} (p, \theta_1, \theta_4) = a_1 \theta_1^2 + b_1 \theta_1 + c_1 + \frac{ a_4 \theta_4^2 + b_4 \theta_4 + c_4 }{p} + \frac{c_3}{1+p}$$

If the sinusoidal fit is used:\\
$$F_{\text{total}} (p, \theta_1, \theta_4)= a_1 \sin\left( \theta_1 + \phi_1  \right)  + c_1 + \frac{a_4 \sin\left( \theta_4 + \phi_4  \right)  + c_4}{p} + \frac{c_3}{1+p}$$

The general shape of the two curves is similar in both cases but the quadratic curve does achieve a somewhat lower squared error. During the fitting process the quadratic curve was not restrained to produce a curve which is continuous from 180° to -180°. This led to a curve that has a small jump at this position which is unphysical, the sinusoidal curve inherently avoids this problem and produces a curve that is continuous everywhere.

 
\subsection{Conclusions}
The dependence of static friction on the position of the carriage follows the expected relationship calculated in Section \ref{sec:staticFricTheory}. At higher $p$-values a lower torque is needed to get the transmission system moving. \\

The positional dependence cannot be explained so simply. Several factors could contribute to the profile seen in the plots above. The shaft not being at the centre of each cone could cause the distance between the cone surfaces to vary as they turn. At alignments where the cone surfaces are closer, the balls would have to compress more, leading to higher normal forces between the cones and the balls, ultimately causing higher static friction. The same variation in distance between the cones could be caused by the cone surfaces not being perfectly circular.\\

The overall trends of the static friction data can be explained by these effects, the local deviations from the trend visible in the plots can be caused by local surface effects at those cone positions. For example, if the balls stop in a small dimple on the cone surface, a higher torque will be needed to get it moving again.



\pagebreak

\section{Dynamic friction}
\subsection{Motivation}
It is assumed that most of the energy losses in the system are due to the dynamic friction between components. These forces and torques could be caused by the rolling friction between the balls and the cones or by the bearings that hold the components. This experiment tries to find the sources and the magnitudes of these losses. Creating a model that describes the operation of the transmission system requires the accurate description of the dynamic friction torques and their dependence on the $p$-value and the shaft positions.



\subsection{Theory}
\label{sec:dynamicTheory}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Dynamic friction model.drawio.png}
    \caption{The dynamic friction model}
    \label{fig:dynFricModel}
\end{figure}
Figure \ref{fig:dynFricModel} shows the forces and torques acting on the components during the dynamic friction experiment, the torques labelled $F_i$ are the dynamic friction forces between the components, $I_c$ is the moment of inertia of a single cone assembly and $\alpha_i$ is the angular acceleration of the component. The rest of the labels have the same meaning as in Figure \ref{fig:staticFricModel}. the inertial forces acting on the balls are ignored, as explained in Section \ref{sec:momentOfInertiaCalcs}. 
Based on the result in Section \ref{sec:staticFricTheory}, the motor torque can be calculated:
$$T_{\text{motor}} = F_1 + I_c\alpha_1 + \frac{F_4 + I_c \alpha_4 }{p} + \frac{c(F_2+F_3)}{1+p}$$

This can be simplified by noting that the ratio of accelerations only depends on the $p$-value: $\alpha_4 = \frac{\alpha_1}{p}$

$$T_{\text{motor}} = F_1 + \left(1+\frac{1}{p^2}\right)I_c\alpha_1 + \frac{F_4 }{p} + \frac{c(F_2+F_3)}{1+p}$$



\subsection{Moment of inertia calculations}
\label{sec:momentOfInertiaCalcs}


\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{coneCrossSection.png}
    \caption{The cross section of the cones}
    \label{fig:coneCrossSection}
\end{figure}

A cross-section of the primary axle and cone is shown in Figure \ref{fig:coneCrossSection}. As this is a hollow cone, the moment of inertia for a solid cone of these dimensions is calculated and then the moment of inertia of the material that is not present in this assembly is subtracted.
The moment of inertia of a solid truncated cone can be calculated by integrating the thin circular disks that make up the cone:
$$I_{\text{solid}} = \int_0^h \rho \frac{r(x)^2}{2} \text{d}V = \frac{\rho \pi }{2} \int_0^h r(x)^4 \text{d}x =\frac{\rho \pi }{2} \int_0^h \left( R_1 + \frac{R_2-R_1}{h}x \right)^4 \text{d}x $$
$$I_{\text{solid}} = \frac{\rho \pi h }{10}\left( \frac{R_2^5-R_1^5}{R_2-R_1}\right)$$
where $\rho = 7600~\frac{\text{kg}}{\text{m}^3}$  is the density of the material, $h = 82.5 $ mm is the height of the cone, $R_1 = 37$~mm and $R_2 = 81.5$ mm are the radii at the two ends. 

$$I_{\text{solid}} = 1.56 \cdot 10^{-2}~\text{kgm}^2$$

To get the moment of inertia of the hollow cone two sections must be removed, a cylindrical one at the base of the cone $D=60$ mm, $h=26.1$ mm) and another truncated cone at the narrower part ($R_1=35$ mm, $R_2=60$ mm, $h=46.6$ mm), the total moment of inertia of these two shapes is: $I_{\text{extra}} = 3.48\cdot 10^{-3}$ kgm$^2$, so the hollow cone's moment of inertia:
$$I_{\text{cone}} = 1.21\cdot 10^{-2}~\text{kgm}^2$$

The moment of inertia of the hollow shaft ($h=171$ mm, $D_1=6.7$ mm, $D_2=19$ mm) that goes through the cone can be calculated in a similar way: 
$$I_{\text{shaft}} = 1.64\cdot 10^{-5}~\text{kgm}^2$$ 

Therefore the moment of inertia of a cone assembly:
$$I_c = I_{\text{cone}}+I_{\text{shaft}} = 8.35 \cdot 10^{-3}$$

The balls inside the carriage have a diameter of 25 mm, so their moment of inertia is:
$$I_{\text{ball}} = \frac{8\pi \rho R_b^5}{15} =3.83\cdot 10^{-6}~\text{kgm}^2$$
This is 3 orders of magnitude smaller than the moment of inertia of the cone-shaft assembly, it's contribution is not included in the model. The moment of inertia of the load cell's rotating components, the rotor of the DC motor and the spring are also omitted as they are even smaller. 


\subsection{Method and program}
The dynamic friction and its dependence on position are measured by driving the transmission system between the two endstops at a constant speed. The torque and the speed of the driveshaft are recorded along with the position of the carriage. Using the equations derived above, the effect of inertial forces and friction forces can be separated and thus the $p$-value and position dependence of the dynamic friction can be described. The dynamic friction was measured at several different speeds to see whether it has any dependence on the speed.\\

The dynamic friction measuring program can be started from the touchscreen interface. Two parameters are required to set up the experiment: cruise speed and acceleration. The cruise speed is the speed that the motor's internal control system is instructed to keep during the test, the acceleration value sets the target acceleration to be used at the endstops when the shaft's rotation is reversed. A higher acceleration value allows the system to remain at the cruise speed for a longer part of the travel, so data can be collected closer to the endstops. The acceleration is limited by the maximum current of the motor's power supply.\\

When the command is received by the backend the two parameters are sent to the drive motor's internal controller. After this step the motor is instructed to travel to the positive endstop at the specified cruise speed. When it reaches the endstop, the transmission system is stopped and instructed to go to the other endstop. This repeats until the system is manually stopped. The algorithm is shown diagrammatically in Figure \ref{fig:dynamicFricFlowChart}.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{DynamicFriction.drawio.png}
    \caption{The flowchart describing the dynamic friction program}
    \label{fig:dynamicFricFlowChart}
\end{figure}

\begin{figure}[h]
\label{fig:dynamicFrictionTorque-position}
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction torque-position (ideal).png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction torque-position (measured).png}
    \end{minipage}
\caption{The expected and the measured results of the dynamic friction measurements}
\end{figure}

The expected result of the experiment is shown in Figure \ref{fig:dynamicFrictionTorque-position}, as the speed is kept constant, the position varies linearly. In the ideal case, the torque is constant and equal to the dynamic friction of the transmission system at the current operating point. In the real case the position of the shaft cannot do the sharp turns shown in the ideal case, so the peaks are rounded. The torque shows some noise around the average value as the motor controller tries to keep the speed at the specified value. As the motor controller cannot react immediately to the changes in dynamic friction, the speed deviates from the specified value as it moves between the endpoints. Note that the drive position points wrap around as the shaft reaches 180° or -180°.


\subsection{Speed dependence}
The speed dependence of the dynamic friction was analysed first. At a given $p$-value and shaft offset, the dynamic friction test was run at 6 different speeds ranging from 200°/s to 1200°/s (33.3-200 RPM). Reducing the speed further caused problems as the unloaded system has very low inertia and a sudden increase in dynamic friction was enough to make the shaft stop, at which point the static friction gets measured instead of the dynamic friction. Increasing the speed also leads to less accurate data because as the speed increases, the number of datapoints recorded during the travel decreases. Changing only the speed and nothing else made it possible to directly compare the required average torques during the constant speed period of the test. The datapoints measured near the endstops were removed from the collected data and the absolute value of the remaining torque values were averaged to find the average dynamic friction at a given speed. \\

Figure \ref{fig:dynamicFrictionSpeedDependence} shows the measured average torques against the cruise speed used during the experiment. No clear dependence on speed can be discerned in the Figure but the expected change in torque as the $p$-value changes is apparent. Somewhat unexpectedly the torque also shows some dependence on the offset between the two shafts. This points to a variation with shaft positions that the static friction also exhibited. 

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{Dynamic friction speed dependence.png}
    \caption{The speed dependence of the dynamic friction}
    \label{fig:dynamicFrictionSpeedDependence}
\end{figure}


\subsection{Position dependence}
The position dependence of the dynamic friction was analysed using a similar method to the one described in Section \ref{sec:staticFricCurve}. The main difference was that the inertia term must be included in these calculations, to correct for the inertia, the following equation was used:\\
$$F_{\text{total}} = T_{\text{motor}}- \left(1+\frac{1}{p^2}\right)I_c\alpha_1 $$
where $\alpha_1$ is the angular acceleration of the primary shaft. These $F_{\text{total}}$ values are plotted against both the position of the input shaft and the position of the output shaft in Figure \ref{fig:dynFricDataCollected} and in the plots in Appendix B. This data is a lot more noisier than the data collected during the static friction experiment. This could be caused by the inaccurate measurement of acceleration as the 100 Hz sampling rate and the resolution of the encoders might not be enough to pick up small changes in acceleration. A small error in the syncing process (described in Section \ref{sec:staticFricSyncing}) can also cause noise that is much more apparent in this experiment as the torque and position values can change quickly. Nonetheless, some variation with position is visible in the plots of the dynamic friction.\\


\subsection{Curve fitting}
The dynamic friction data recorded was passed through the same curve-fitting algorithm to produce a pair of best-fit lines that describe the variation with shaft position. This process also removes high-frequency variations from the data. A quadratic and a sinusoidal fit was generated in this case as well. As seen in Figure \ref{fig:dynFricDataCollected} the generated splines loosely follow the "centre of mass" of the measured data but the fits are not nearly as good as they were for the static friction data. The resulting splines are given in the following equations with their coefficients in Table \ref{tab:dynFricCoeffs}. $c_3$ refers to the friction of the balls, $c(F_2+F_3)$ in the torque equations.

Quadratic:
$$F_i = a_i \theta_i^2 + b_i \theta_i + c_i$$
Sinusoidal:
$$F_i = a_i \sin\left( \theta_i + \phi_i  \right)  + c_i$$

 
\begin{table}[h]
    \centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{Quadratic}     & \multicolumn{2}{|c|}{Sinusoidal}    \\ \hline
$a_1$        & -9.73E-07 & $c_1$         & 1.13E-01 \\ \hline
$b_1$        & 5.92E-05  & $c_2$         & 2.54E-02 \\ \hline
$c_1$        & 1.23-01  & $c_3$         & 1.01E-0.4 \\ \hline
$a_2$        & -4.04E-06 & $a_1$         & 1.56E-02 \\ \hline
$b_2$        & -5.97E-05 & $a_2$         & 3.29E-02 \\ \hline
$c_2$        & 5.70E-02  & $\phi_1$         & 44.7°\\ \hline
$c_3$        & 1.00E-04  & $\phi_2$         & 100° \\ \hline
\end{tabular}
    \caption{The best-fit coefficients.}
    \label{tab:dynFricCoeffs}
\end{table}
These curves are shown in Figure \ref{fig:dynFitCurves} along with the previously found static friction curves.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1.42, offset-60.png}
    \caption{The inertia corrected dynamic friction data }
    \label{fig:dynFricDataCollected}
\end{figure}


\subsection{Comparison with static friction}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{BothF1.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{BothF4.png}
    \end{minipage}
\label{fig:dynFitCurves}
\caption{The best-fit static and dynamic $F_1$ and $F_4$ curves}

\end{figure}
The curves generated based on the two datasets have a similar shape, with the peaks around the 0° position and decreased friction on the opposite sides of the cones. As expected the magnitude of the static friction is greater than the magnitude of the static friction. 

\subsection{Conclusions}
Initially, three parameters were identified that could influence the dynamic friction: shaft speed, shaft positions and carriage position. The speed dependence was analysed first but no variation could be identified. \\

The variation with shaft position and $p$-value was much stronger. These were modelled using best-fit curves. The positional variance of the friction measured during the static friction test can be seen in the dynamic friction data as well. It is assumed that the same phenomenon causes these variations in both cases.\\

The measured dynamic friction values do not follow the best-fit curves as closely as the static friction values did so the confidence in these best-fit curves is much lower.

\clearpage
\section{Spring characterisation}
\label{sec:spring}
The next part of the project focused on the torsion spring that can be connected to the driven shaft. In order to include it in the model that describes the whole system, its torque-twist characteristic was measured experimentally. It is assumed that the spring behaves linearly and thus it can be described by the equation:
$$T_{\text{spring}} = \kappa \theta_4 $$
where $\kappa$ is a constant and $\theta_4$ is the position of the driven shaft. (The spring is clamped so that it is unstressed at the $\theta_4 = 0$° position.) 

\subsection{Static characterisation}
The static friction algorithm was run again with the spring connected. The test was done at three different $p$-values. \\

Including the torque of the spring in the model described in Section \ref{sec:staticFricTheory} gives the following equation:
$$T_{\text{motor}} = F_1(\theta_1) + \frac{F_4(\theta_4)+ T_{\text{spring}}(\theta_4)}{p} + \frac{c(F_2+F_3)}{1+p}$$

Using the best-fit lines found in Section \ref{sec:staticFricCurve} for the friction values, the added torque due to the spring can be found. The $T_{\text{spring}}$ values calculated using this method are shown in Figure \ref{fig:springStatic}. 





\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{SpringStatic.png}
    \caption{The measured static spring torque plotted against $\theta_4$}
    \label{fig:springStatic}
\end{figure}


\subsection{Dynamic characterisation}
The dynamic friction experiment was also conducted again with the spring connected to the secondary shaft. As the magnitude of friction is lower in this case the torque of the spring is easier to measure. The datapoints recorded are shown in Figure \ref{fig:springDynamic}. 

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{SpringDynamic.png}
    \caption{The measured dynamic spring torque plotted against $\theta_4$}
    \label{fig:springDynamic}
\end{figure}

\subsection{Best-fit slope}
The best-fit slope of the collected torque-rotation was found using the least-squares method. The result of this fit: $$\kappa = 8.80  \pm 0.07 ~\frac{\text{mNm}}{1 \text{°}} = 0.504 \pm 0.004  ~\frac{\text{Nm}}{\text{rad}} $$

\clearpage
\section{Power losses}
\subsection{Motivation}
The previous friction measurements were all conducted on an unloaded transmission system. Analysing the behaviour of the system under load gives useful insight into the opearation under conditions that are more likely to occur during use of the system. This experiment aims to determine whether the model derived in unloaded conditions remains accurate when there is a load connected to the secondary shaft. 

\subsection{Theory}
The equation derived in Section \ref{sec:dynamicTheory} is modified by adding a term for output torque and by combining the three friction terms into one ($F$):
$$T_{\text{motor}} = F + \left(1+\frac{1}{p^2}\right)I_c\alpha_1 + T_{\text{load}}$$

The load is the spring which can be described with the equation:
$$ T_{\text{load}} = \kappa \theta_4$$
The value of $\kappa$ was found in Section \ref{sec:spring}.


\subsection{Method}
The sinusoidal drive mode was used to conduct the power measurements. Both the drive motor and the carriage motor was driven in a sinusoidal fashion to achieve many different shaft and carriage position combinations (shown in Figure \ref{fig:powerSines}). The goal was to measure the friction in position combinations where it was not measured previously. This was done to test the predictive capability of the created model.\\

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{PowerDriveSine.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{PowerCarriageSine.png}
    \end{minipage}
\label{fig:powerSines}
\caption{The positions of the shafts and the carriage plotted against time}
\end{figure}


For each datapoint the friction ($F$ in the equations above) was calculated. This was multiplied by the instantaneous speed to find the power loss. 

\clearpage
\subsection{Comparison to the model's predicted values}
\clearpage

\printbibliography

\clearpage
\setkeys{Gin}{draft}
\section*{Appendix A: Static friciton data}
\addcontentsline{toc}{section}{\protect\numberline{}Appendix A: Static friciton data}%


\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p0.68, o-120, op.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1, o-120, op.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o20, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-60, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-60, op.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-120, ip.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Static friction data/p1.43, o-120, op.png}
    \end{minipage}

\end{figure}

\clearpage
\newgeometry{top=1.5cm, bottom=1.5cm, left=2.5cm, right=2.5cm}
\section*{Appendix B: Dynamic friction data}
\addcontentsline{toc}{section}{\protect\numberline{}Appendix B: Dynamic friction data}%
\setlength{\floatsep}{0.1pt}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p0.63, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p0.63, offset-60.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p0.63, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p0.63, offset-120.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p0.63, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p0.63, offset20.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p0.63, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p0.63, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p0.63, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p0.63, offset-120.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p0.63, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p0.63, offset20.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p0.63, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p0.63, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p0.63, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p0.63, offset-120.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p0.63, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p0.63, offset20.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1, offset-60.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1, offset-120.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1, offset20.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1, offset-120.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1, offset20.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1, offset-120.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1, offset20.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1.42, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1.42, offset-60.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed200, p1.42, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1.42, offset-120.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1.42, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed400, p1.42, offset20.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1.42, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1.42, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed600, p1.42, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1.42, offset-120.png}
    \end{minipage}

\end{figure}
\clearpage
\newgeometry{top=1.5cm, bottom=2cm, left=2.5cm, right=2.5cm}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1.42, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed800, p1.42, offset20.png}
    \end{minipage}

\end{figure}

\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1.42, offset-120.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1.42, offset-60.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1000, p1.42, offset20.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1.42, offset-120.png}
    \end{minipage}

\end{figure}
\begin{figure}[!h]
    \centering
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1.42, offset-60.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}       
         \includegraphics[width=\textwidth]{Dynamic friction plots/dynFricspeed1200, p1.42, offset20.png}
    \end{minipage}

\end{figure}

\section*{Appendix C: Risk assessment retrospective}
\addcontentsline{toc}{section}{\protect\numberline{}Appendix C: Risk assessment retrospective}%
In the risk assessment form the hazards identified were the mains electricity that powers the system, the moving components of the transmission and the manual handling of the apparatus.\\
As all the high voltage electrical connections are contained within the power supply housing, they only pose a danger when the covers are removed. At no point during the project was it necessary to remove these covers. Similarly the enclosure that contains the moving components remained closed during the whole project. \\
The transmission was moved between offices once at the start of the project. A trolley was used and care was taken when lifting the tranmission on/off the trolley. \\
No previously unseen risk was identified during the project.  
\end{document}
