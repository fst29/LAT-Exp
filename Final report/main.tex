\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage[a4paper, 
            top=2.5cm, 
            bottom=2.5cm,
            right=2.5cm,
            left=2.5cm]{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{changepage}
\usepackage[sorting=none]{biblatex} %Imports biblatex package
\usepackage{titlesec}
\addbibresource{references.bib}

%\titlespacing*{\section}
%{0pt}{2.2ex plus 1ex minus .2ex}{1.3ex plus .2ex}
%\titlespacing*{\subsection}
%{0pt}{1.4ex plus 1ex minus .2ex}{0.6ex plus .2ex}



\author{Fl칩ri치n Tiefenbeck (fst29)}


%\topmargin 0.0cm \oddsidemargin 0.0in \evensidemargin 0.0in
%\textheight 25cm \textwidth  17cm \headheight 0in \headsep 0in
\parindent 0in
%\parskip \bigskipamount
\pagenumbering{gobble}
\begin{document}

\begin{center}
{\Huge \bf Final report}\\
\vspace{6pt}
{\LARGE \bf Experimental testing and modelling of a continuously variable transmission}\\
\vspace{4pt}
{\LARGE Fl칩ri치n Tiefenbeck (fst29, Peterhouse)}\\
%{\LARGE Michelmas, 2023 }
\end{center}

\section{Technical abstract}

\section{Background}

\subsection{Motivation}

\subsection{Design}

Output encoder: RE30E1024-213-1

\subsection{Dimensions}

\subsection{Previous work}



\section{Software design}
All of the software used to control the experiments or manually move the motors was written during this project. There are two main programs running on the Raspberry Pi during operation. One is communicating with the sensors and the motors (backend), the other is communicating with the user (frontend). This separation allowed two different programming languages to be used for the two programs, so the strenghts of each language could be utilised.

\subsection{Backend}
The backend program is written in the C++ language. This was chosen for two reasons, the first is the inherent speed of the language as it is a compiled language. This allows the program to run at high speeds even on such relatively weak hardware as the Raspberry Pi. This enabled higher sampling frequencies to be used and finer control of the motors. The other reason for choosing this language was the availability of the official motor control library created by the manufacturers of the motors. This library contains makes interfacing with the motors a much simpler task by creating an abstraction layer. This means that in the backend program simple commands can be used to control the motors, which are then translated to the more complex low-level instructions by the library.

The backend program has two main parts, first a setup part that runs once on startup, then a loop that runs until the program is stopped.

The setup part estabilishes the connection with the motors, sets up the secondary encoder, initialises the message-reader and creates the file that is used to save all the measured data. The loop part has three main tasks, it collects measurements, it sends commands to the motors and saves the collected data to the output file.  

\subsubsection{Variables}
\subsubsection{Motor setup}
The motor setup utilises functions from the afforementioned motor library. Initially communication is estabilished with the motors using the CAN bus adapter. Once a stable link is created, the PID parameters, the maximum torque, the maximum speed, maximum acceleration, the internal loop frequency, and the maximum current draw get set. The values used here were determined previously and were not changed. 

\subsubsection{Secondary encoder}
The encoder connected to the secondary shaft is connected directly to the Raspberry Pi using the GPIO headers. The encoder is an incremental quadratic type, which means it has two outputs (A and B) which change as shown in Figure \ref{fig:encoder}. At each encoder tick (corresponds to 1/1024 of a full rotation of the encoder equal to 1/(1024*4) of the seconder shaft) one of the two signals changes. By treating the encoder as a two bit state machine a state transition table can be created as shown in Table \ref{tab:output_encoder}.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        Previous state (AB) & Current state & Movement&Value of \verb|output_encoder_state|& Corresponding value of \verb|state_transition_matrix| \\
         & 
    \end{tabular}
    \caption{Caption}
    \label{tab:output_encoder}
\end{table}

During this part of the program interrupts are attached to the two encoder pins. These interrupts call the same function (called \verb|encoder_callback|) if one of the signals changes in either direction.

A global variable called \verb|output_encoder_state| is also created, this is a four bit number that represents the current and the previous state of the encoder signals in the format (in binary) A\textsubscript{n-1}B\textsubscript{n-1}A\textsubscript{n}B\textsubscript{n}. 

A lookup table (\verb|state_stranstion_matrix|) is also created from the state transition table shown in Table \ref{tab:output_encoder}. It has 16 elements corresponding to each possible transition, the positive transitions have value +1, the negative transitions have value -1, the entries corresponding to no movement or error have value 0. After creating the table, its values get scaled by 360/(1024*4) to get the result in degrees.

When the callback function is called, \verb|output_encoder_state| gets bit-shifted left by two bits and bitwise ended with 1100, effectively moving the "current" measurement to the location of the previous and deleting the previous. After the shift, the lower two bits get populated with the new values of the encoder output. The last step of the callback function is to add the value of the state transition matrix to the variable that stores the position of the secondary shaft. This is implemented by adding the \verb|output_encoder_state|'th element of the \verb|state_transition_matrix| array to the position variable.

Using these bitwise operations and the lookup table allows the callback function to be executed very quickly. This is important as this is an interrupt so the rest of the program is halted while this runs.




\begin{figure}
    \centering
    \includegraphics{}
    \caption{The output waveforms of the encoder}
    \label{fig:encoder}
\end{figure}
\TODO get figure and put it here


\subsubsection{Message-reader}
\subsubsection{Output file}



\subsubsection{Timing of the loop}
constant loop, check if enough time has elapsed, if so, do stuff

\subsubsection{Collecting measurements}
first part of the loop, has two parts

\subsubsubsection{Motors}
commands sent to the motors over CAN, wait for response, ask for position, velocity and current draw, talk about units here



\subsubsection{Controlling motors}
\subsubsection{Saving data}
\subsubsection{Sending data}


\subsection{Frontend}
The frontend is made using the Python language and the Tkinter GUI module. The language was selected because it is a high level language that enables quick development. The main drawback of the language is its relatively slow execution time but this is not relevant for a user interface. The Tkinter module makes GUI development simpler by adding pre-built interface elements, such as buttons or textboxes. These can be configured and placed in the window to build up the user interface. The module also offers touchscreen compatibility, which is required here. 

Visually the window is split vertically into two sections. The upper part contains the numpad and measured data display area. The lower part is used to control the apparatus with different commands split across the different tabs.

The frontend utilises two threads, just like the backend. The first thread is responsible for the received messages from the backend, the other thread handles the input from the user and sends it to the backend.


\subsubsection{Numpad}
As the Raspberry Pi is not connected to any keyboards, only the touchscreen, the only way to input numbers was the on-screen keyboard of the operating system. Using this proved to be cumbersome as this is a full keyboard that takes up most of the screen. During operation only numerical data needs to entered, therefore a numpad was included in the user interface, that is always visible and enters numbers into the selected textbox. The numpad contains the numbers 0-9, a decimal point, a negative sign and a backspace key. Switching from the OS's keyboard to this numpad made using the GUI significantly faster.


\subsection{Measurement display area}
This area remains visible at all times and shows the position and velocity of all encoders, the current draw of both motors is also displayed. This area is updated using the first thread of the frontend, where an infinite loop is running, which checks for a message coming from the backend in each iteration. If no message is received it halts until a message appears. When a message is received it checks whether the format of the message is correct and raises an error if it isn't. In the next step the data is extracted from the message and the text displayed in the measurement display area gets updated. 

\subsubsection{Manual page}
\subsubsection{Initialise page}
\subsubsection{Sinusoidal page}
\subsection{PID page}

\subsection{Communication}
formats, supported keywords etc.


\section{Initialisation algorithms}
\subsection{Primary shaft}
\subsection{Secondary shaft}
\subsection{Carriage}

\section{Static friction}
\subsection{Motivation}

\subsection{Static friction model}
\subsubsection{Modelling rolling friction}
\subsection{Method and program}

flowchart here

first method -> single tick detection -> false positives -> double tick method


\subsection{Collected data}
\subsection{Curve fitting}
\subsection{Conclusions}





all data as appendix 

\subsection{Data processing}

\section{Dynamic friction}



\subsection{Theory}

\subsection{Moment of inertia calculations}






\section{Risk assessment retrospective}



\end{document}
