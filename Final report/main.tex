\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage[a4paper, 
            top=2.5cm, 
            bottom=2.5cm,
            right=2.5cm,
            left=2.5cm]{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{changepage}
\usepackage[sorting=none]{biblatex} %Imports biblatex package
\usepackage{titlesec}
\addbibresource{references.bib}

%\titlespacing*{\section}
%{0pt}{2.2ex plus 1ex minus .2ex}{1.3ex plus .2ex}
%\titlespacing*{\subsection}
%{0pt}{1.4ex plus 1ex minus .2ex}{0.6ex plus .2ex}

%background: 5
%software: 10
%init: 2
% static fric: 10+3data
% dyn fric: 10+3data
%
%
%


\author{Fl칩ri치n Tiefenbeck (fst29)}


%\topmargin 0.0cm \oddsidemargin 0.0in \evensidemargin 0.0in
%\textheight 25cm \textwidth  17cm \headheight 0in \headsep 0in
\parindent 0in
%\parskip \bigskipamount
\pagenumbering{gobble}
\begin{document}

\begin{center}
{\Huge \bf Final report}\\
\vspace{6pt}
{\LARGE \bf Experimental testing and modelling of a continuously variable transmission}\\
\vspace{4pt}
{\LARGE Fl칩ri치n Tiefenbeck (fst29, Peterhouse)}\\
%{\LARGE Michelmas, 2023 }
\end{center}

\section{Technical abstract}

\section{Background}
The design was conceived during a project where \todo names where trying to create a losslessly adjustable inerter and a losslessly adjustable spring. These are devices where the inertance or the spring constant can be changed during operation without any energy input. Their search was motivated by the ubiquity of variable dampeners commonly used in the auto industry. Linear devices were investaged initially such as the one shown in Figure \todo. \todo Explain operation. 
Later during the project, they have started looking at rotating devices. This eliminates the problem caused by physical limits and saturation (as explained in Lucas's paper). The two cone desing shown in Figure \todo was created. Attachin a spring or an inerter to one side of the transmission creates the losslessly adjustable device as desired. 





\subsection{Motivation}
As this is a new design, its operational parameters are generally unknown. This project aims to measure the most important such parameters such as the friction during operation or the slip between components.


\subsection{Design}

\subsubsection{Transmission}
The main part of the transmission consists of two counterrotating cones on two parallel shafts. The cones are facing in the opposite direction, so that the distance between their surfaces remains constant. A carriage is suspended between the two cones, that is free to move along the length of the cone surfaces. The carriage holds two metal balls that are in contact with the cones and eachother. They can rotate freely in any direction, allowing torque to be transmitted from one shaft to the other.

\subsubsection{Auxillary components}
Motors, 

spring, 

encoder
Output encoder: RE30E1024-213-1 \cite{encoder}

Raspi
Screen
CAN adapter




\subsection{Dimensions}

\subsection{Comparision to other CVT designs}


\subsection{Previous work}



\section{Software design}
All of the software used to control the experiments or manually move the motors was written during this project. There are two main programs running on the Raspberry Pi during operation. One is communicating with the sensors and the motors (backend), the other is communicating with the user (frontend). This separation allowed two different programming languages to be used for the two programs, so the strenghts of each language could be utilised.

\subsection{Backend}
The backend program is written in the C++ language. This was chosen for two reasons, the first is the inherent speed of the language as it is a compiled language. This allows the program to run at high speeds even on such relatively weak hardware as the Raspberry Pi. This enabled higher sampling frequencies to be used and finer control of the motors. The other reason for choosing this language was the availability of the official motor control library created by the manufacturers of the motors. This library contains makes interfacing with the motors a much simpler task by creating an abstraction layer. This means that in the backend program simple commands can be used to control the motors, which are then translated to the more complex low-level instructions by the library.

The backend program has two main parts, first a setup part that runs once on startup, then a loop that runs until the program is stopped.

The setup part estabilishes the connection with the motors, sets up the secondary encoder, initialises the message-reader and creates the file that is used to save all the measured data. The loop part has three main tasks, it collects measurements, it sends commands to the motors and saves the collected data to the output file.  

\subsubsection{Variables}
\subsubsection{Motor setup}
The motor setup utilises functions from the afforementioned motor library. Initially communication is estabilished with the motors using the CAN bus adapter. Once a stable link is created, the PID parameters, the maximum torque, the maximum speed, maximum acceleration, the internal loop frequency, and the maximum current draw get set. The values used here were determined previously and were not changed. 

\subsubsection{Secondary encoder}
The encoder connected to the secondary shaft is connected directly to the Raspberry Pi using the GPIO headers. The encoder is an incremental quadratic type, which means it has two outputs (A and B) which change as shown in Figure \ref{fig:encoder}. At each encoder tick (corresponds to 1/1024 of a full rotation of the encoder equal to 1/(1024*4) of the seconder shaft) one of the two signals changes. By treating the encoder as a two bit state machine a state transition table can be created as shown in Table \ref{tab:output_encoder}.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
        Previous  & Current  & Movement&Value of & Value in \\
        state (A\textsubscript{n-1}B\textsubscript{n-1}) & state (A\textsubscript{n}B\textsubscript{n})&&\verb|output_encoder_state|& lookup table\\%\verb|state_transition_matrix| \\
        \hline
         00&00&None&0000\textsubscript{2}=0\textsubscript{10}&0\\ 
         00&01&CCW&0001\textsubscript{2}=1\textsubscript{10}&+1\\ 
         00&10&CW&0010\textsubscript{2}=2\textsubscript{10}&-1\\ 
         00&11&Error&0011\textsubscript{2}=3\textsubscript{10}&0\\ 
         
         01&00&CW&0100\textsubscript{2}=4\textsubscript{10}&-1\\ 
         01&01&None&0101\textsubscript{2}=5\textsubscript{10}&0\\ 
         01&10&Error&0110\textsubscript{2}=6\textsubscript{10}&0\\ 
         01&11&CCW&0111\textsubscript{2}=7\textsubscript{10}&+1\\ 
         
         10&00&CCW&1000\textsubscript{2}=8\textsubscript{10}&+1\\ 
         10&01&Error&1001\textsubscript{2}=9\textsubscript{10}&0\\ 
         10&10&None&1010\textsubscript{2}=10\textsubscript{10}&0\\ 
         10&11&CW&1011\textsubscript{2}=11\textsubscript{10}&-1\\ 
         
         11&00&Error&1100\textsubscript{2}=12\textsubscript{10}&0\\ 
         11&01&CW&1101\textsubscript{2}=13\textsubscript{10}&-1\\ 
         11&10&CCW&1110\textsubscript{2}=14\textsubscript{10}&+1\\ 
         11&11&None&1111\textsubscript{2}=15\textsubscript{10}&0\\ 
         \hline
    \end{tabular}
    \caption{State transition table of the secondary endcoder (Note that the actual values of the lookup table are scaled to give result in degrees)}
    \label{tab:output_encoder}
\end{table}

During this part of the program interrupts are attached to the two encoder pins. These interrupts call the same function (called \verb|encoder_callback|) if one of the signals changes in either direction.

A global variable called \verb|output_encoder_state| is also created, this is a four bit number that represents the current and the previous state of the encoder signals in the format (in binary) A\textsubscript{n-1}B\textsubscript{n-1}A\textsubscript{n}B\textsubscript{n}. 

A lookup table (\verb|state_stranstion_matrix|) is also created from the state transition table shown in Table \ref{tab:output_encoder}. It has 16 elements corresponding to each possible transition, the positive transitions have value +1, the negative transitions have value -1, the entries corresponding to no movement or error have value 0. After creating the table, its values get scaled by 360/(1024*4) to get the result in degrees.

When the callback function is called, \verb|output_encoder_state| gets bit-shifted left by two bits and bitwise ended with 1100, effectively moving the "current" measurement to the location of the previous and deleting the previous. After the shift, the lower two bits get populated with the new values of the encoder output. The last step of the callback function is to add the value of the state transition matrix to the variable that stores the position of the secondary shaft. This is implemented by adding the \verb|output_encoder_state|'th element of the \verb|state_transition_matrix| array to the position variable.

Using these bitwise operations and the lookup table allows the callback function to be executed very quickly. This is important as this is an interrupt so the rest of the program is halted while this runs.




\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{encoder_waveform.png}
    \caption{The output waveforms of the encoder, Figure from \cite{encoder}}
    \label{fig:encoder}
\end{figure}



\subsubsection{Message-reader}
\subsubsection{Output file}



\subsubsection{Timing of the loop}
constant loop, check if enough time has elapsed, if so, do stuff

\subsubsection{Collecting measurements}
first part of the loop, has two parts

\subsubsubsection{Motors}
commands sent to the motors over CAN, wait for response, ask for position, velocity and current draw, talk about units here



\subsubsection{Controlling motors}
\subsubsection{Saving data}
\subsubsection{Sending data}


\subsection{Frontend}
The frontend is made using the Python language and the Tkinter GUI module. The language was selected because it is a high level language that enables quick development. The main drawback of the language is its relatively slow execution time but this is not relevant for a user interface. The Tkinter module makes GUI development simpler by adding pre-built interface elements, such as buttons or textboxes. These can be configured and placed in the window to build up the user interface. The module also offers touchscreen compatibility, which is required here. 

Visually the window is split vertically into two sections. The upper part contains the numpad and measured data display area. The lower part is used to control the apparatus with different commands split across the different tabs.

The frontend utilises two threads, just like the backend. The first thread is responsible for the received messages from the backend, the other thread handles the input from the user and sends it to the backend.


\subsubsection{Numpad}
As the Raspberry Pi is not connected to any keyboards, only the touchscreen, the only way to input numbers was the on-screen keyboard of the operating system. Using this proved to be cumbersome as this is a full keyboard that takes up most of the screen. During operation only numerical data needs to entered, therefore a numpad was included in the user interface, that is always visible and enters numbers into the selected textbox. The numpad contains the numbers 0-9, a decimal point, a negative sign and a backspace key. Switching from the OS's keyboard to this numpad made using the GUI significantly faster.


\subsubsection{Measurement display area}
This area remains visible at all times and shows the position and velocity of all encoders, the current draw of both motors is also displayed. This area is updated using the first thread of the frontend, where an infinite loop is running, which checks for a message coming from the backend in each iteration. If no message is received it halts until a message appears. When a message is received it checks whether the format of the message is correct and raises an error if it isn't. In the next step the data is extracted from the message and the text displayed in the measurement display area gets updated. 

\subsubsection{Manual page}
\subsubsection{Initialise page}
\subsubsection{Sinusoidal page}
\subsection{PID page}

\subsection{Communication}
formats, supported keywords etc.


\section{Initialisation algorithms}
\subsection{Primary shaft}
\subsection{Secondary shaft}
\subsection{Carriage}

\section{Static friction}
\subsection{Motivation}

\subsection{Static friction model}
\subsubsection{Modelling rolling friction}
\subsection{Method and program}

flowchart here

first method -> single tick detection -> false positives -> double tick method


\subsection{Collected data}
\subsection{Curve fitting}
\subsection{Conclusions}





all data as appendix 

\subsection{Data processing}

\section{Dynamic friction}



\subsection{Theory}

\subsection{Moment of inertia calculations}






\section{Risk assessment retrospective}

\printbibliography

\end{document}
